--- /dev/null
+++ b/sound/soc/ar71xx/Kconfig
@@ -0,0 +1,21 @@
+config SND_SOC_AR71XX_PCM
+	tristate "test based on qca i2s driver"
+	select REGMAP_MMIO
+	help
+	  Say Y or M...
+
+config SND_SOC_AR71XX_I2S
+	tristate "SoC Audio support for the AR71XX I2S Module"
+	select REGMAP_MMIO
+	select SND_SOC_DMAENGINE_PCM
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M...
+
+config SND_SOC_AR71XX_HIFIBERRY_DAC
+	tristate "Hifiberry DAC Machine Driver"
+	depends on SND_SOC_AR71XX_I2S
+	select SND_SOC_PCM5102A
+	help
+	  Say Y or M...
+
--- /dev/null
+++ b/sound/soc/ar71xx/Makefile
@@ -0,0 +1,13 @@
+# AR71XX Platform Support
+snd-soc-ar71xx-i2s-objs := ar71xx-i2s.o
+snd-soc-ar71xx-pcm-objs := ar71xx-pcm.o ar71xx-mbox.o
+#snd-soc-ar71xx-mbox-objs := ar71xx-mbox.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_I2S) += snd-soc-ar71xx-i2s.o
+obj-$(CONFIG_SND_SOC_AR71XX_PCM) += snd-soc-ar71xx-pcm.o
+#obj-$(CONFIG_SND_SOC_AR71XX_MBOX) += snd-soc-ar71xx-mbox.o
+
+# AR71XX Machine Support
+snd-soc-ar71xx-hifiberry-dac-objs := hifiberry_dac.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) += snd-soc-ar71xx-hifiberry-dac.o
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.c
@@ -0,0 +1,807 @@
+//TODO setup gpio pins somewhere
+
+/*
+ * ALSA SoC I2S Audio Layer for Broadcom AR71XX SoC
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * Based on
+ *	Raspberry Pi PCM I2S ALSA Driver
+ *	Copyright (c) by Phil Poole 2013
+ *
+ *	ALSA SoC I2S (McBSP) Audio Layer for TI DAVINCI processor
+ *      Vladimir Barinov, <vbarinov@embeddedalley.com>
+ *	Copyright (C) 2007 MontaVista Software, Inc., <source@mvista.com>
+ *
+ *	OMAP ALSA SoC DAI driver using McBSP port
+ *	Copyright (C) 2008 Nokia Corporation
+ *	Contact: Jarkko Nikula <jarkko.nikula@bitmer.com>
+ *		 Peter Ujfalusi <peter.ujfalusi@ti.com>
+ *
+ *	Freescale SSI ALSA SoC Digital Audio Interface (DAI) driver
+ *	Author: Timur Tabi <timur@freescale.com>
+ *	Copyright 2007-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include "ar71xx-i2s.h"
+
+
+enum {
+	AR71XX_CLK_SRC_CPU = 0,
+	AR71XX_CLK_SRC_OSC,
+};
+
+
+static const unsigned int ar71xx_clk_freq[AR71XX_CLK_SRC_OSC+1] = {
+	[AR71XX_CLK_SRC_CPU]		= 400000000,
+	[AR71XX_CLK_SRC_OSC]		= 176000000,
+};
+
+/* GPIOs for Regmap testing */
+#define AR71XX_GPIO_OE			0x00
+#define AR71XX_GPIO_SET			0x0c
+#define AR71XX_GPIO_CLEAR		0x10
+
+#define AR71XX_GPIO_PIN(v)		(1 << (v))
+
+
+/* GPIO function registers */
+#define AR71XX_GPIO_FUNCTION			0x28
+#define AR71XX_GPIO_FUNCTION_SPDIF2TCK		BIT(31)
+#define AR71XX_GPIO_FUNCTION_SPDIF_EN		BIT(30)
+#define AR71XX_GPIO_FUNCTION_I2SO_22_18_EN	BIT(29)
+#define AR71XX_GPIO_FUNCTION_I2S_MCKEN		BIT(27)
+#define AR71XX_GPIO_FUNCTION_I2SO_EN		BIT(26)
+
+/* I2S registers */
+#define AR71XX_I2S_STEREO0_CONFIG		0x00
+#define AR71XX_I2S_STEREO0_VOLUME		0x04
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_LSB	0x0C
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_MSB	0x10
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_LSB	0x14
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_MSB	0x18
+#define AR71XX_I2S_STEREO0_CLK_DIV		0x1C
+
+/* STEREO0_CONFIG masks */
+#define AR71XX_I2S_DIV_BYPASS			BIT(25)
+#define AR71XX_I2S_AUDIO_CLOCK_SEL		BIT(24)
+#define AR71XX_I2S_SPDIF_ENABLE			BIT(23)
+#define AR71XX_I2S_REFCLK_SEL			BIT(22)
+#define AR71XX_I2S_ENABLE			BIT(21)
+#define AR71XX_I2S_MIC_RESET			BIT(20)
+#define AR71XX_I2S_RESET			BIT(19)
+#define AR71XX_I2S_I2S_DELAY			BIT(18)
+#define AR71XX_I2S_PCM_SWAP			BIT(17)
+#define AR71XX_I2S_MIC_WORD_SIZE		BIT(16)
+#define AR71XX_I2S_SETERO_MONO(v)		(((v) & 0x3) << 14)
+enum {
+	AR71XX_I2S_STEREO = 0,
+	AR71XX_I2S_MONO_CHNL0,
+	AR71XX_I2S_MONO_CHNL1,
+};
+
+#define AR71XX_I2S_DATA_WORD_SIZE(v)		(((v) & 0x3) << 12)
+enum {
+	AR71XX_I2S_DATA_WORD_8 = 0,
+	AR71XX_I2S_DATA_WORD_16,
+	AR71XX_I2S_DATA_WORD_24,
+	AR71XX_I2S_DATA_WORD_32,
+};
+
+#define AR71XX_I2S_I2S_WORD_SIZE		BIT(11)
+#define AR71XX_I2S_MCK_SEL			BIT(10)
+#define AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE	BIT(9)
+#define AR71XX_I2S_MASTER			BIT(8)
+#define AR71XX_I2S_POSEDGE(v)			((v) & 0x7f)
+#define AR71XX_I2S_POSEDGE_MASK			0x7f
+
+/* STEREO0_VOLUME masks */
+#define AR71XX_I2S_CHANNEL1(v)			((v) << 8)
+#define AR71XX_I2S_CHANNEL0(v)			(v)
+
+/* Tx and Rx Counter masks */
+#define AR71XX_I2S_SAMPLE_COUNTER_CH0		(0xFFFF)
+#define AR71XX_I2S_SAMPLE_COUNTER_CH1		(0xFFFF << 16)
+
+/* STEREO_CLOCK_DIV masks */
+#define AR71XX_I2S_CLK_SHIFT			16
+#define AR71XX_I2S_CLK_DIVF_MASK		0xffff
+#define AR71XX_I2S_DIV_INT(v)			((v) << AR71XX_I2S_CLK_SHIFT)
+#define AR71XX_I2S_DIV_FRAC(v)			(v)
+
+
+/* General device struct */
+struct ar71xx_i2s_dev {
+	struct device		*dev;
+	
+	struct regmap 		*i2s_regmap;
+	struct regmap 		*gpio_regmap;
+
+	//TODO check if needed
+	struct snd_dmaengine_dai_dma_data	dma_data[2];
+	unsigned int				fmt;
+	unsigned int				bclk_ratio;
+
+};
+
+#if 0
+static void ar71xx_i2s_start_clock(struct ar71xx_i2s_dev *dev)
+{
+	printk("called start clock\n");
+
+	/* Start da clock */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+		AR71XX_I2S_ENABLE, AR71XX_I2S_ENABLE);
+}
+
+static void ar71xx_i2s_stop_clock(struct ar71xx_i2s_dev *dev)
+{
+	printk("called stop clock\n");
+
+	/* Stop clock */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_ENABLE, 0x00);
+
+}
+#endif
+
+void ar71xx_stereo_reset(struct ar71xx_i2s_dev *dev)
+{
+	/* set reset bit in STEREO0_CONFIG */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 
+			AR71XX_I2S_RESET, AR71XX_I2S_RESET);
+}
+
+#if 0
+static void ar71xx_i2s_clear_fifos(struct ar71xx_i2s_dev *dev,
+				    bool tx, bool rx)
+{
+
+	printk("called clear fifos\n");
+#if 0
+	/* Reset Buffers */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+		AR71XX_I2S_MIC_RESET | AR71XX_I2S_RESET,
+		AR71XX_I2S_MIC_RESET | AR71XX_I2S_RESET);
+	
+
+	int timeout = 1000;
+	uint32_t syncval;
+	uint32_t csreg;
+	uint32_t i2s_active_state;
+	uint32_t clkreg;
+	uint32_t clk_active_state;
+	uint32_t off;
+	uint32_t clr;
+
+	off =  tx ? AR71XX_I2S_TXON : 0;
+	off |= rx ? AR71XX_I2S_RXON : 0;
+
+	clr =  tx ? AR71XX_I2S_TXCLR : 0;
+	clr |= rx ? AR71XX_I2S_RXCLR : 0;
+
+	/* Backup the current state */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &csreg);
+	i2s_active_state = csreg & (AR71XX_I2S_RXON | AR71XX_I2S_TXON);
+
+	regmap_read(dev->clk_regmap, AR71XX_CLK_PCMCTL_REG, &clkreg);
+	clk_active_state = clkreg & AR71XX_CLK_ENAB;
+
+	/* Start clock if not running */
+	if (!clk_active_state) {
+		regmap_update_bits(dev->clk_regmap, AR71XX_CLK_PCMCTL_REG,
+			AR71XX_CLK_PASSWD_MASK | AR71XX_CLK_ENAB,
+			AR71XX_CLK_PASSWD | AR71XX_CLK_ENAB);
+	}
+
+	/* Stop I2S module */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, off, 0);
+
+	/*
+	 * Clear the FIFOs
+	 * Requires at least 2 PCM clock cycles to take effect
+	 */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, clr, clr);
+
+	/* Wait for 2 PCM clock cycles */
+
+	/*
+	 * Toggle the SYNC flag. After 2 PCM clock cycles it can be read back
+	 * FIXME: This does not seem to work for slave mode!
+	 */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &syncval);
+	syncval &= AR71XX_I2S_SYNC;
+
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_SYNC, ~syncval);
+
+	/* Wait for the SYNC flag changing it's state */
+	while (--timeout) {
+		regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &csreg);
+		if ((csreg & AR71XX_I2S_SYNC) != syncval)
+			break;
+	}
+
+	if (!timeout)
+		dev_err(dev->dev, "I2S SYNC error!\n");
+
+	/* Stop clock if it was not running before */
+	if (!clk_active_state)
+		ar71xx_i2s_stop_clock(dev);
+
+	/* Restore I2S state */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_RXON | AR71XX_I2S_TXON, i2s_active_state);
+#endif
+}
+#endif
+
+static int ar71xx_i2s_set_dai_fmt(struct snd_soc_dai *dai,
+				      unsigned int fmt)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	dev->fmt = fmt;
+	return 0;
+}
+
+
+static int ar71xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	unsigned int sampling_rate = params_rate(params);
+	unsigned int divi, divf, mclk_frequency, posedge;
+	unsigned int conf, i2s_word_size;
+	unsigned int master = dev->fmt & SND_SOC_DAIFMT_MASTER_MASK;
+	int clk_src = AR71XX_CLK_SRC_CPU;
+	int channels;
+#if 0
+	bool bit_master =	(master == SND_SOC_DAIFMT_CBS_CFS
+					|| master == SND_SOC_DAIFMT_CBS_CFM);
+
+	bool frame_master =	(master == SND_SOC_DAIFMT_CBS_CFS
+					|| master == SND_SOC_DAIFMT_CBM_CFS);
+#endif
+
+
+	unsigned int mclk_ratio = 256;  /* see supported ratios of TAS5711 */
+	uint64_t dividend;
+	uint32_t confreg = 0;
+
+	printk("called hw params, dev=%p, dev->gpio_regmap=%p, dev->i2s_regmap=%p\n", 
+		dev, dev->gpio_regmap, dev->i2s_regmap);
+
+#if 0
+	//XXX test regmap read on gpio_regmap
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, &confreg);
+	printk("after regmap_read, stereo0_config=0x%08X\n", confreg);
+
+	regmap_read(dev->gpio_regmap, AR71XX_GPIO_FUNCTION, &confreg);
+	printk("after regmap_read, gpio_function=0x%08X\n", confreg);
+#endif	
+
+	//TODO delete this as stereo0_config isn't 0 on default
+	/*
+	 * If a stream is already enabled,
+	 * the registers are already set properly.
+	 */
+#if 0	
+	if (confreg)
+		return 0;
+#endif
+
+	
+
+	
+
+	/* Set configurations 
+	 *
+	 * DIV_BYPASS = 0 	--> Divider not bypassed
+	 * AUDIO_CLOCK_SEL = 0	--> use CPU clock
+	 * SPDIF_ENABLE = 0	--> SPDIF is disabled
+	 * SAMPLE_CNT_CLEAR_TYPE = 0 --> explicit zero is written to sample counters
+	 */
+	conf = 0;
+
+#if 0
+	// TODO this becomes false and returns here
+	/* Clock inversion is not supported */
+	if ((dev->fmt & SND_SOC_DAIFMT_INV_MASK) == SND_SOC_DAIFMT_NB_NF) {
+		dev_err(dev->dev, "Clock inversion not supported\n");
+		return -EINVAL;
+	}
+#endif
+
+	
+	/* Set master/slave */
+	switch (dev->fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* CPU is master */
+		conf |= AR71XX_I2S_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* CODEC is master */
+		//TODO has to be tested!
+		conf |= AR71XX_I2S_REFCLK_SEL;
+		conf |= AR71XX_I2S_MCK_SEL;
+		break;
+	default:
+		dev_err(dev->dev, "%s:bad master\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set format */
+	switch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		conf |= AR71XX_I2S_I2S_DELAY;
+		break;
+	default:
+		/*
+		 * TODO
+		 * Others are possible but are not implemented at the moment.
+		 * Only unset delay bit??
+		 */
+		dev_err(dev->dev, "%s:bad format\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set output (I2S DAC) word size */
+	//TODO
+	// 1 = 32 Bit
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_8);
+		i2s_word_size = 8;
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S16_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_16);
+		i2s_word_size = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S24_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_24);
+		conf |= AR71XX_I2S_I2S_WORD_SIZE;
+		conf |= AR71XX_I2S_MIC_WORD_SIZE; /* check if good here */
+		i2s_word_size = 24;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S32_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_32);
+		conf |= AR71XX_I2S_I2S_WORD_SIZE;
+		conf |= AR71XX_I2S_MIC_WORD_SIZE;
+		i2s_word_size = 32;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* Set Stereo/Mono */
+	switch (params_channels(params)) {
+	case 2:
+		//TODO mono supported? set STEREO_MONO
+		/* Stereo is default so STEREO_MONO needn't be set */
+		channels = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* Write configurations to register */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, conf, conf);
+
+
+	mclk_frequency = sampling_rate * mclk_ratio * 2; // TODO find out where the 2 comes from. what a mistery! 
+
+	dividend = ar71xx_clk_freq[clk_src];
+	dividend <<= AR71XX_I2S_CLK_SHIFT;
+	do_div(dividend, mclk_frequency);
+	divi = dividend >> AR71XX_I2S_CLK_SHIFT;
+	divf = dividend & AR71XX_I2S_CLK_DIVF_MASK;
+
+	posedge = mclk_ratio / (channels * 64);
+
+
+	/* Set clock divider */
+	regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CLK_DIV,
+			AR71XX_I2S_DIV_INT(divi) | AR71XX_I2S_DIV_FRAC(divf));
+
+	//TODO do only one write to STEREO0_CONFIG
+	/* Set posedge */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_POSEDGE_MASK, AR71XX_I2S_POSEDGE(posedge));
+
+
+	ar71xx_stereo_reset(dev);
+
+	//TODO these registers might be in the MBOX
+	//leave it empty for now as we only care about the clock
+#if 0
+	/* Setup the DMA parameters */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_RXTHR(1)
+			| AR71XX_I2S_TXTHR(1)
+			| AR71XX_I2S_DMAEN, 0xffffffff);
+
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_DREQ_A_REG,
+			  AR71XX_I2S_TX_PANIC(0x10)
+			| AR71XX_I2S_RX_PANIC(0x30)
+			| AR71XX_I2S_TX(0x30)
+			| AR71XX_I2S_RX(0x20), 0xffffffff);
+
+	/* Clear FIFOs */
+	ar71xx_i2s_clear_fifos(dev, true, true);
+#endif
+
+	printk("return 0 of hw_params\n");
+	return 0;
+
+}
+
+#if 0
+static void ar71xx_i2s_stop(struct ar71xx_i2s_dev *dev,
+		struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	//uint32_t mask;
+
+	printk("called stop\n");
+
+#if 0
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = AR71XX_I2S_RXON;
+	else
+		mask = AR71XX_I2S_TXON;
+
+	regmap_update_bits(dev->i2s_regmap,
+			AR71XX_I2S_CS_A_REG, mask, 0);
+#endif
+
+	/* Stop also the clock when not SND_SOC_DAIFMT_CONT */
+	if (!dai->active && !(dev->fmt & SND_SOC_DAIFMT_CONT))
+		ar71xx_i2s_stop_clock(dev);
+}
+#endif
+
+static int ar71xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+
+static int ar71xx_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	
+	printk("called startup\n");
+
+	/* Route the i2s pins to the gpios */
+	regmap_update_bits(dev->gpio_regmap, 
+		AR71XX_GPIO_FUNCTION,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN);
+
+
+	if (!dai->active) {
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 
+			  AR71XX_I2S_SPDIF_ENABLE 
+			| AR71XX_I2S_ENABLE
+			| AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE
+			| AR71XX_I2S_MASTER);
+	
+		ar71xx_stereo_reset(dev);
+	}
+
+	return 0;
+}
+
+static void ar71xx_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	
+	printk("called shutdown\n");
+
+	/* If both streams are stopped, disable module and clock */
+	if (dai->active) {
+		printk("setting STEREO0_CONFIG to 0x00\n");
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 0x00);
+		ar71xx_stereo_reset(dev);
+	} else { //XXX force stopping for now
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 0x00);
+		ar71xx_stereo_reset(dev);
+	}
+}
+
+
+static const struct snd_soc_dai_ops ar71xx_i2s_dai_ops = {
+
+	.startup	= ar71xx_i2s_startup,
+	.shutdown	= ar71xx_i2s_shutdown,
+	.trigger	= ar71xx_i2s_trigger,
+	.hw_params	= ar71xx_i2s_hw_params,
+	.set_fmt 	= ar71xx_i2s_set_dai_fmt,
+
+};
+
+static int ar71xx_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK];
+	dai->capture_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE];
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver ar71xx_i2s_dai = {
+	//TODO check available formats on ar9331
+	.name	= "ar71xx-i2s",
+	.id	= 0,
+//	.probe	= ar71xx_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_44100 |
+		                SNDRV_PCM_RATE_48000 |
+		                SNDRV_PCM_RATE_88200 |
+		                SNDRV_PCM_RATE_96000,
+		.formats =	SNDRV_PCM_FMTBIT_S8 |
+				SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_S16_LE |
+				//TODO QCA driver says 32 bit is really noisy. has to be tested
+				SNDRV_PCM_FMTBIT_S24_BE |
+				SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_S32_BE |
+				SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_44100 |
+		                SNDRV_PCM_RATE_48000 |
+		                SNDRV_PCM_RATE_88200 |
+		                SNDRV_PCM_RATE_96000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S32_BE |
+				SNDRV_PCM_FMTBIT_S32_LE 
+		}, 
+	.ops = &ar71xx_i2s_dai_ops,
+	.symmetric_rates = 1 //TODO whats this??
+};
+
+#if 0
+
+static bool ar71xx_i2s_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_CS_A_REG:
+	case AR71XX_I2S_FIFO_A_REG:
+	case AR71XX_I2S_INTSTC_A_REG:
+	case AR71XX_I2S_GRAY_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_i2s_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_FIFO_A_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_clk_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_CLK_PCMCTL_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+#endif
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	/* I2S Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_I2S_STEREO0_CLK_DIV,
+		//.precious_reg = ar71xx_i2s_precious_reg,
+		//.volatile_reg = ar71xx_i2s_volatile_reg,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* GPIO Registers (only GPIO Function) */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_GPIO_FUNCTION,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+
+
+static const struct snd_soc_component_driver ar71xx_i2s_component = {
+	.name		= "ar71xx-i2s-comp",
+};
+
+//do in ar71xx_pcm.c
+#if 0
+static const struct snd_pcm_hardware ar71xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_JOINT_DUPLEX,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S24_LE |
+				  SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 64 * PAGE_SIZE,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.buffer_bytes_max	= 128 * PAGE_SIZE,
+};
+
+static const struct snd_dmaengine_pcm_config ar71xx_dmaengine_pcm_config = {
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.pcm_hardware = &ar71xx_pcm_hardware,
+	.prealloc_buffer_size = 256 * PAGE_SIZE,
+};
+#endif
+
+
+static int ar71xx_i2s_probe(struct platform_device *pdev)
+{
+	struct ar71xx_i2s_dev *dev;
+	int i;
+	int ret;
+	struct regmap *regmap[2];
+	struct resource *mem[2];
+
+
+	printk("started probe\n");
+
+
+	/* Request ioareas */
+	for (i = 0; i < 2; i++) {
+		void __iomem *base;
+
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base,
+					    &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "I2S probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	}
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev),
+			   GFP_KERNEL);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	dev->i2s_regmap = regmap[0];
+	dev->gpio_regmap = regmap[1];
+
+
+#if 0
+	/* Set the DMA address */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	/* Set the DREQ */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].slave_id =
+		AR71XX_DMA_DREQ_PCM_TX;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].slave_id =
+		AR71XX_DMA_DREQ_PCM_RX;
+
+	/* Set the bus width */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	/* Set burst */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 2;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 2;
+	
+	/* BCLK ratio - use default */
+	dev->bclk_ratio = 0;
+
+#endif
+	/* Store the pdev */
+	dev->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, dev);
+
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&ar71xx_i2s_component, &ar71xx_i2s_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+#if 0
+	ret = snd_dmaengine_pcm_register(&pdev->dev,
+				&ar71xx_dmaengine_pcm_config,
+				SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		snd_soc_unregister_component(&pdev->dev);
+		return ret;
+	}
+#endif
+
+
+	return 0;
+}
+
+static int ar71xx_i2s_remove(struct platform_device *pdev)
+{
+	printk("called remove\n");
+	
+	//snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_i2s_driver = {
+	.probe		= ar71xx_i2s_probe,
+	.remove		= __exit_p(ar71xx_i2s_remove),
+	.driver		= {
+		.name	= "ar71xx-i2s",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_i2s_driver);
+
+MODULE_ALIAS("platform:ar71xx-i2s");
+MODULE_DESCRIPTION("AR71XX I2S interface");
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_GENERIC_DMAENGINE_PCM
 	select SND_SOC_DMAENGINE_PCM
 
 # All the supported SoCs
+source "sound/soc/ar71xx/Kconfig"
 source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/blackfin/Kconfig"
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -12,6 +12,7 @@ endif
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/
 obj-$(CONFIG_SND_SOC)	+= generic/
+obj-$(CONFIG_SND_SOC)	+= ar71xx/
 obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= blackfin/
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -105,6 +105,8 @@ int snd_soc_dai_set_clkdiv(struct snd_so
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, int source, unsigned int freq_in, unsigned int freq_out);
 
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int radio);
+
 /* Digital Audio interface formatting */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt);
 
@@ -131,6 +133,7 @@ struct snd_soc_dai_ops {
 	int (*set_pll)(struct snd_soc_dai *dai, int pll_id, int source,
 		unsigned int freq_in, unsigned int freq_out);
 	int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
+	int (*set_bclk_ratio)(struct snd_soc_dai *dai, unsigned int radio);
 
 	/*
 	 * DAI format configuration
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.h
@@ -0,0 +1,43 @@
+/*
+ * I2S configuration for sound cards. 
+ *
+ * Copyright (c) 2014 Daniel Matuschek <daniel@hifiberry.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AR71XX_I2S_H
+#define AR71XX_I2S_H
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+//TODO check if needed
+#include <sound/dmaengine_pcm.h>
+
+
+
+#endif
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3398,6 +3398,22 @@ int snd_soc_codec_set_sysclk(struct snd_
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 
 /**
+ * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio: Rtio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio
+ */
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	if (dai->driver && dai->driver->ops->set_bclk_ratio)
+		return dai->driver->ops->set_bclk_ratio(dai, ratio);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
+
+/**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
  * @div_id: DAI specific clock divider ID
--- a/arch/mips/ath79/mach-carambola2.c
+++ b/arch/mips/ath79/mach-carambola2.c
@@ -18,6 +18,7 @@
 #include "dev-spi.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
+#include "dev-pcm.h"
 #include "machtypes.h"
 
 #define CARAMBOLA2_GPIO_LED_WLAN		0
@@ -61,6 +62,72 @@ static struct gpio_keys_button carambola
 	},
 };
 
+#ifdef CONFIG_SND_SOC_AR71XX_PCM_MODULE
+static struct resource ar9331_pcm_resources[] = {
+	{
+		.start	= AR933X_MBOX_BASE,
+		.end	= AR933X_MBOX_BASE + AR933X_MBOX_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "mbox-registers-pcm"
+	},
+	{
+		.start	= AR933X_RST_RESET_BASE,
+		.end	= AR933X_RST_RESET_BASE + AR933X_RST_RESET_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "reset-registers-pcm"
+	},
+	{
+		.start	= AR933X_RST_MISC_INT_BASE,
+		.end	= AR933X_RST_MISC_INT_BASE + AR933X_RST_MISC_INT_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "misc-int-registers-pcm"
+	},
+};
+
+static struct platform_device ar9331_pcm_device = {
+	.name		= "ar71xx-pcm",
+	.resource	= ar9331_pcm_resources,
+	.num_resources	= ARRAY_SIZE(ar9331_pcm_resources),
+};
+#endif
+
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+static struct resource ar9331_i2s_resources[] = {
+	{
+		.start	= AR933X_I2S_BASE,
+		.end	= AR933X_I2S_BASE + AR933X_I2S_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "i2s-registers-i2s"
+	},
+	{
+		.start	= AR71XX_GPIO_BASE,
+		.end	= AR71XX_GPIO_BASE + AR71XX_GPIO_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "gpio-registers-i2s"
+	}
+};
+
+static struct platform_device ar9331_i2s_device = {
+	.name		= "ar71xx-i2s",
+	.resource	= ar9331_i2s_resources,
+	.num_resources	= ARRAY_SIZE(ar9331_i2s_resources),
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+static struct platform_device snd_hifiberry_dac_device = {
+	.name 		= "snd-hifiberry-dac",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static struct platform_device snd_pcm5102a_codec_device = {
+	.name		= "pcm5102a-codec",
+	.id		= -1,
+	.num_resources	= 0,
+};
+#endif
+
 static void __init carambola2_common_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
@@ -81,6 +148,22 @@ static void __init carambola2_common_set
 
 	/* WAN port */
 	ath79_register_eth(0);
+
+#ifdef CONFIG_SND_SOC_AR71XX_PCM_MODULE
+	/* PCM module */
+	ath79_register_pcm(&ar9331_pcm_device);
+#endif
+
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+	/* I2S module */
+	ath79_register_pcm(&ar9331_i2s_device);
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+	/* Hifiberry dac module */
+	ath79_register_pcm(&snd_hifiberry_dac_device);
+	ath79_register_pcm(&snd_pcm5102a_codec_device);
+#endif
 }
 
 static void __init carambola2_setup(void)
--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
@@ -94,6 +94,16 @@
 #define AR933X_WMAC_SIZE	0x20000
 #define AR933X_EHCI_BASE	0x1b000000
 #define AR933X_EHCI_SIZE	0x1000
+#define AR933X_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+#define AR933X_RESET_SIZE	0xb0
+#define AR933X_RST_RESET_BASE	(AR71XX_APB_BASE + 0x0006001c)
+#define AR933X_RST_RESET_SIZE	0x00
+#define AR933X_RST_MISC_INT_BASE	(AR71XX_APB_BASE + 0x00060010)
+#define AR933X_RST_MISC_INT_SIZE	0x04
+#define AR933X_I2S_BASE		(AR71XX_APB_BASE + 0x000B0000)
+#define AR933X_I2S_SIZE		0x20
+#define AR933X_MBOX_BASE	(AR71XX_APB_BASE + 0x000A0000)
+#define AR933X_MBOX_SIZE	0x58
 
 #define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
 #define AR934X_GMAC_SIZE	0x14
--- a/arch/mips/ath79/Kconfig
+++ b/arch/mips/ath79/Kconfig
@@ -1014,6 +1014,7 @@ config ATH79_MACH_CARAMBOLA2
 	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
+	select ATH79_DEV_PCM
 
 config ATH79_MACH_BHU_BXU2000N2_A
 	bool "BHU BXU2000n-2 rev. A support"
@@ -1100,6 +1101,9 @@ config ATH79_DEV_SPI
 config ATH79_DEV_USB
 	def_bool n
 
+config ATH79_DEV_PCM
+	def_bool n
+
 config ATH79_DEV_WMAC
 	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
 	def_bool n
--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_ATH79_DEV_NFC)		+= dev-nfc.
 obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
 obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
 obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+obj-$(CONFIG_ATH79_DEV_PCM)		+= dev-pcm.o
 
 #
 # Miscellaneous objects
--- /dev/null
+++ b/sound/soc/ar71xx/hifiberry_dac.c
@@ -0,0 +1,117 @@
+/*
+ * ASoC Driver for HifiBerry DAC
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * TODO:
+ * - CPU DAI Name
+ * - Platform Name
+ *
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+
+static int snd_rpi_hifiberry_dac_init(struct snd_soc_pcm_runtime *rtd)
+{
+	printk("in dac_init\n");
+	return 0;
+}
+
+static int snd_rpi_hifiberry_dac_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	unsigned int sample_bits =
+		snd_pcm_format_physical_width(params_format(params));
+	unsigned int fmt = 1;//TODO
+
+	printk("in dac_hw_params\n");
+	
+
+	//return snd_soc_dai_set_bclk_ratio(cpu_dai, sample_bits * 2);
+	//return snd_soc_dai_set_fmt(cpu_dai, fmt);
+	return 0;
+}
+
+/* machine stream operations */
+static struct snd_soc_ops snd_rpi_hifiberry_dac_ops = {
+	.hw_params = snd_rpi_hifiberry_dac_hw_params,
+};
+
+static struct snd_soc_dai_link snd_rpi_hifiberry_dac_dai[] = {
+{
+	.name		= "HifiBerry DAC",
+	.stream_name	= "HifiBerry DAC HiFi",
+	.cpu_dai_name	= "ar71xx-i2s.0",
+	.codec_dai_name	= "pcm5102a-hifi",
+	.platform_name	= "ar71xx-pcm.0",
+	.codec_name	= "pcm5102a-codec",
+	.dai_fmt	= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				SND_SOC_DAIFMT_CBS_CFS,
+	.ops		= &snd_rpi_hifiberry_dac_ops,
+	.init		= snd_rpi_hifiberry_dac_init,
+},
+};
+
+/* audio machine driver */
+static struct snd_soc_card snd_rpi_hifiberry_dac = {
+	.name         = "snd_carambola2_hifiberry_dac",
+	.dai_link     = snd_rpi_hifiberry_dac_dai,
+	.num_links    = ARRAY_SIZE(snd_rpi_hifiberry_dac_dai),
+};
+
+static int snd_rpi_hifiberry_dac_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	dev_info(&pdev->dev, "in ..._dac_probe()\n");
+
+	snd_rpi_hifiberry_dac.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_rpi_hifiberry_dac);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+
+	return ret;
+}
+
+static int snd_rpi_hifiberry_dac_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "in ..._dac_remove()\n");
+
+	return snd_soc_unregister_card(&snd_rpi_hifiberry_dac);
+}
+
+static struct platform_driver snd_rpi_hifiberry_dac_driver = {
+        .driver = {
+                .name   = "snd-hifiberry-dac",
+                .owner  = THIS_MODULE,
+        },
+        .probe          = snd_rpi_hifiberry_dac_probe,
+        .remove         = snd_rpi_hifiberry_dac_remove,
+};
+
+module_platform_driver(snd_rpi_hifiberry_dac_driver);
+
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_DESCRIPTION("ASoC Driver for HifiBerry DAC");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -55,6 +55,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ML26124 if I2C
 	select SND_SOC_OMAP_HDMI_CODEC if OMAP4_DSS_HDMI
 	select SND_SOC_PCM3008
+	select SND_SOC_PCM5102A
 	select SND_SOC_RT5631 if I2C
 	select SND_SOC_SGTL5000 if I2C
 	select SND_SOC_SI476X if MFD_SI476X_CORE
@@ -293,6 +294,9 @@ config SND_SOC_OMAP_HDMI_CODEC
 config SND_SOC_PCM3008
        tristate
 
+config SND_SOC_PCM5102A
+       tristate
+
 config SND_SOC_RT5631
 	tristate
 
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -43,6 +43,7 @@ snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-omap-hdmi-codec-objs := omap-hdmi.o
 snd-soc-pcm3008-objs := pcm3008.o
+snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-rt5631-objs := rt5631.o
 snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-alc5623-objs := alc5623.o
@@ -170,6 +171,7 @@ obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_OMAP_HDMI_CODEC) += snd-soc-omap-hdmi-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
+obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
 obj-$(CONFIG_SND_SOC_SGTL5000)  += snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_SIGMADSP)	+= snd-soc-sigmadsp.o
--- /dev/null
+++ b/sound/soc/codecs/pcm5102a.c
@@ -0,0 +1,73 @@
+/*
+ * Driver for the PCM5102A codec
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static struct snd_soc_dai_driver pcm5102a_dai = {
+	.name = "pcm5102a-hifi",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   // SNDRV_PCM_FMTBIT_S24_LE | : disable for now, it causes white noise with xbmc
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE | 
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_pcm5102a;
+
+static int pcm5102a_probe(struct platform_device *pdev)
+{
+	printk("in pcm5102a_probe()\ndoing snd_soc_register_codec() now\n");
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pcm5102a,
+			&pcm5102a_dai, 1);
+}
+
+static int pcm5102a_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver pcm5102a_codec_driver = {
+	.probe 		= pcm5102a_probe,
+	.remove 	= pcm5102a_remove,
+	.driver		= {
+		.name	= "pcm5102a-codec",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(pcm5102a_codec_driver);
+
+MODULE_DESCRIPTION("ASoC PCM5102A codec driver");
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-mbox.c
@@ -0,0 +1,412 @@
+/*
+ * ath79-mbox.c -- ALSA MBOX DMA management functions
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/types.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#include "ar71xx-pcm.h"
+
+spinlock_t ar71xx_pcm_lock;
+static struct dma_pool *ar71xx_pcm_cache;
+
+void ar71xx_mbox_reset(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	//u32 t;
+	printk("in mbox_reset, dev: %p, dev->mbox_regmap: %p, dev->reset_regmap %p\n", 
+		dev, dev->mbox_regmap, dev->reset_regmap);
+
+	//TODO spin_lock needed?
+	spin_lock(&ar71xx_pcm_lock);
+
+	regmap_update_bits(dev->reset_regmap, 
+			AR9331_RESET_RST_RESET,
+			AR9331_RESET_RST_RESET_MBOX,
+			AR9331_RESET_RST_RESET_MBOX);
+	
+	printk("in mbox_reset, after first regmap_update_bits\n");
+	//t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+	//t |= AR934X_RESET_MBOX;
+	//ath79_reset_wr(AR934X_RESET_REG_RESET_MODULE, t);
+	
+	udelay(50);
+	printk("in mbox_reset, after udelay\n");
+	//t &= ~(AR934X_RESET_MBOX);
+	//ath79_reset_wr(AR934X_RESET_REG_RESET_MODULE, t);
+	regmap_update_bits(dev->reset_regmap, 
+			AR9331_RESET_RST_RESET,
+			AR9331_RESET_RST_RESET_MBOX, 0);
+	printk("in mbox_reset, after second regmap_update_bits\n");
+
+	spin_unlock(&ar71xx_pcm_lock);
+}
+
+void ar71xx_mbox_fifo_reset(bool rx, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	printk("in mbox_fifo_reset\n");
+	if (rx) {
+	regmap_update_bits(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_FIFO_RESET,
+			AR9331_MBOX_DMA_FIFO_RESET_RX_INIT,
+			AR9331_MBOX_DMA_FIFO_RESET_RX_INIT);
+	} else {
+	regmap_update_bits(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_FIFO_RESET,
+			AR9331_MBOX_DMA_FIFO_RESET_TX_INIT,
+			AR9331_MBOX_DMA_FIFO_RESET_TX_INIT);
+	}
+
+	//ar71xx_dma_wr(AR934X_DMA_REG_MBOX_FIFO_RESET, mask);
+	udelay(50);
+	/* Datasheet says we should reset the stereo controller whenever
+	 * we reset the MBOX DMA controller */
+	
+	//TODO disable for now because its the wrong dev
+	// cont't know if the reset in the i2s register is enough
+//ar71xx_stereo_reset(dev);
+#if 0
+	regmap_write(dev->reset_regmap, 
+			AR9331_RESET_RST_RESET,
+			AR9331_RESET_RST_RESET_I2S);
+#endif
+}
+
+void ar71xx_mbox_interrupt_enable(u32 mask, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	//u32 t;
+	u32 reg;
+
+	//TODO check if spin_lock is needed	
+	spin_lock(&ar71xx_pcm_lock);
+
+	regmap_update_bits(dev->mbox_regmap, AR9331_MBOX_INT_ENABLE,
+			mask, mask);
+
+	regmap_read(dev->mbox_regmap, AR9331_MBOX_INT_ENABLE,
+			&reg);
+
+	//XXX disabling makes no difference at the moment, maybe not needed
+#if 0
+	regmap_update_bits(dev->misc_int_regmap, AR9331_RESET_RST_MISC_INT_MASK,
+			AR9331_RESET_RST_MISC_INT_MASK_MBOX,	
+			AR9331_RESET_RST_MISC_INT_MASK_MBOX);
+#endif
+
+	//t = ath79_dma_rr(AR934X_DMA_REG_MBOX_INT_ENABLE);
+	//t |= mask;
+	//ath79_dma_wr(AR934X_DMA_REG_MBOX_INT_ENABLE, t);
+
+	spin_unlock(&ar71xx_pcm_lock);
+
+	printk("enabled interrupt wiht %08x, value now at %08x\n", mask, reg);
+}
+
+void ar71xx_mbox_interrupt_ack(u32 mask, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+	//ath79_dma_wr(AR934X_DMA_REG_MBOX_INT_STATUS, mask);
+	regmap_write(dev->mbox_regmap, AR9331_MBOX_INT_STATUS, mask);
+
+	//not available on 9331, if resetting this bit, the carambola 2 restarts
+	//ath79_reset_wr(AR71XX_RESET_REG_MISC_INT_STATUS, ~(MISC_INT_DMA));
+	//regmap_write(dev->reset_regmap, AR9331_RESET_RST_MISC_INT_STATUS, ~(MISC_INT_DMA));
+
+	/* Flush these two registers */
+	//ath79_dma_rr(AR934X_DMA_REG_MBOX_INT_STATUS);
+	regmap_read(dev->mbox_regmap, AR9331_MBOX_INT_STATUS, &reg);
+
+	//ath79_reset_rr(AR71XX_RESET_REG_MISC_INT_STATUS);
+	//regmap_read(dev->reset_regmap, AR9331_RESET_RST_MISC_INT_STATUS, &reg);
+}
+
+void ar71xx_mbox_dma_rx_resume(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+
+	regmap_write(dev->mbox_regmap, 
+		AR9331_MBOX_DMA_RX_CONTROL, 
+		AR9331_MBOX_DMA_CONTROL_RESUME);
+	regmap_read(dev->mbox_regmap,
+		AR9331_MBOX_DMA_RX_CONTROL, &reg);
+	printk("mbox resume: %08x\n", reg);
+}
+
+void ar71xx_mbox_dma_start(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+#define TIMER_VAL	100
+	u32 reg;
+	int timer;
+
+	printk("starting dma\n");
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+#if 0
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_RX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_STOP);
+#endif
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_RX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_START);
+
+		for(timer = TIMER_VAL; timer > 0; timer--) {
+			regmap_read(dev->mbox_regmap,
+				AR9331_MBOX_DMA_RX_CONTROL, &reg);
+			if(!reg) 
+				break;
+		}
+		printk("mbox start: %08x, timer=%d\n", reg, timer);
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX0_DMA_RX_CONTROL,
+		//	     AR934X_DMA_MBOX_DMA_CONTROL_START);
+		//ath79_dma_rr(AR934X_DMA_REG_MBOX0_DMA_RX_CONTROL);
+	} else {
+#if 0
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_TX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_STOP);
+#endif
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_TX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_START);
+
+		for(timer = TIMER_VAL; timer > 0; timer--) {
+			regmap_read(dev->mbox_regmap,
+				AR9331_MBOX_DMA_TX_CONTROL, &reg);
+			if(!reg) 
+				break;
+		}
+		printk("mbox start: %08x, timer=%d\n", reg, timer);
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX0_DMA_TX_CONTROL,
+		//	     AR934X_DMA_MBOX_DMA_CONTROL_START);
+		//ath79_dma_rr(AR934X_DMA_REG_MBOX0_DMA_TX_CONTROL);
+	}
+#undef TIMER_VAL
+
+}
+
+void ar71xx_mbox_dma_stop(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+
+	printk("stopping dma\n");
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_RX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_STOP);
+		regmap_read(dev->mbox_regmap,
+			AR9331_MBOX_DMA_RX_CONTROL, &reg);
+	} else {
+		regmap_write(dev->mbox_regmap, 
+			AR9331_MBOX_DMA_TX_CONTROL, 
+			AR9331_MBOX_DMA_CONTROL_STOP);
+		regmap_read(dev->mbox_regmap,
+			AR9331_MBOX_DMA_TX_CONTROL, &reg);
+	}
+	printk("mbox stop: %08x\n", reg);
+
+	/* Delay for the dynamically calculated max time based on
+	sample size, channel, sample rate + margin to ensure that the
+	DMA engine will be truly idle. */
+	//TODO timer
+
+	mdelay(rtpriv->delay_time);
+}
+
+void ar71xx_mbox_dma_reset(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	printk("in mbox_dma_reset, dev: %p\n", dev);	
+	ar71xx_mbox_reset(dev);
+
+	/* reset both fifos */
+	ar71xx_mbox_fifo_reset(true, dev);
+	ar71xx_mbox_fifo_reset(false, dev);
+}
+
+void ar71xx_mbox_dma_prepare(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	struct ar71xx_pcm_desc *desc;
+	//u32 reg;
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Request the DMA channel to the controller */
+		//t = ath79_dma_rr(AR934X_DMA_REG_MBOX_DMA_POLICY);
+		regmap_update_bits(dev->mbox_regmap, 
+				AR9331_MBOX_DMA_POLICY,
+				AR9331_MBOX_DMA_POLICY_RX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6),
+				AR9331_MBOX_DMA_POLICY_RX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6));
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX_DMA_POLICY,
+		//	     t | AR934X_DMA_MBOX_DMA_POLICY_RX_QUANTUM |
+		//	     (6 << AR934X_DMA_MBOX_DMA_POLICY_TX_FIFO_THRESH_SHIFT));
+
+		/* The direction is indicated from the DMA engine perspective
+		 * i.e. we'll be using the RX registers for Playback and
+		 * the TX registers for capture */
+		desc = list_first_entry(&rtpriv->dma_head, struct ar71xx_pcm_desc, list);
+		//regmap_read(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, &reg);
+		//desc->phys = reg;
+		regmap_write(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, (u32)desc->phys);
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX0_DMA_RX_DESCRIPTOR_BASE,
+		//		(u32) desc->phys);
+		ar71xx_mbox_interrupt_enable(AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE, dev);
+	} else {
+		/* Request the DMA channel to the controller */
+		//t = ath79_dma_rr(AR934X_DMA_REG_MBOX_DMA_POLICY);
+		regmap_update_bits(dev->mbox_regmap, 
+				AR9331_MBOX_DMA_POLICY,
+				AR9331_MBOX_DMA_POLICY_TX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6),
+				AR9331_MBOX_DMA_POLICY_TX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6));
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX_DMA_POLICY,
+		//	     t | AR934X_DMA_MBOX_DMA_POLICY_TX_QUANTUM |
+		//	     (6 << AR934X_DMA_MBOX_DMA_POLICY_TX_FIFO_THRESH_SHIFT));
+
+		desc = list_first_entry(&rtpriv->dma_head, struct ar71xx_pcm_desc, list);
+		//regmap_read(dev->mbox_regmap, AR9331_MBOX_DMA_TX_DESCRIPTOR_BASE, &reg);
+		//desc->phys = reg;
+		regmap_write(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, (u32)desc->phys);
+		//ath79_dma_wr(AR934X_DMA_REG_MBOX0_DMA_TX_DESCRIPTOR_BASE,
+		//		(u32) desc->phys);
+		ar71xx_mbox_interrupt_enable(AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE, dev);
+	}
+
+	// XXX enable all mbox interrupts!
+#if 0
+	u32 int_en = AR9331_MBOX_INT_ENABLE_TX_DMA_EOM_COMPLETE |
+			AR9331_MBOX_INT_ENABLE_TX_OVERFLOW |
+			AR9331_MBOX_INT_ENABLE_RX_UNDERFLOW;
+	ar71xx_mbox_interrupt_enable(int_en, dev);
+#endif
+
+	printk("mbox_dma_prepare, descriptor base: %08x\n", (u32)desc->phys);
+}
+
+int ar71xx_mbox_dma_map(struct ar71xx_pcm_rt_priv *rtpriv, dma_addr_t baseaddr,
+			      int period_bytes, int bufsize)
+{
+	struct list_head *head = &rtpriv->dma_head;
+	struct ar71xx_pcm_desc *desc, *prev;
+	dma_addr_t desc_p;
+	unsigned int offset = 0;
+	int desc_numb = 0;
+
+	printk("in dma_map\n");
+
+	spin_lock(&ar71xx_pcm_lock);
+
+
+	rtpriv->elapsed_size = 0;
+	/* We loop until we have enough buffers to map the requested DMA area */
+	do {
+		/* Allocate a descriptor and insert it into the DMA ring */
+		desc = dma_pool_alloc(ar71xx_pcm_cache, GFP_KERNEL, &desc_p);
+		if(!desc) {
+			return -ENOMEM;
+		}
+		memset(desc, 0, sizeof(struct ar71xx_pcm_desc));
+		desc->phys = desc_p;
+		list_add_tail(&desc->list, head);
+
+		desc->OWN = 1;
+		//not really needed
+		desc->rsvd1 = desc->rsvd2 = desc->rsvd3 = desc->EOM = 0;
+
+		/* buffer size may not be a multiple of period_bytes */
+		if (bufsize >= offset + period_bytes) {
+			desc->size = period_bytes;
+		} else {
+			desc->size = bufsize - offset;
+		}
+		desc->BufPtr = baseaddr + offset;
+
+		/* For now, we assume the buffer is always full
+		 * -->length == size */
+		desc->length = desc->size;
+
+		/* We need to make sure we are not the first descriptor.
+		 * If we are, prev doesn't point to a struct ar71xx_pcm_desc */
+		if (desc->list.prev != head) {
+			prev =
+			    list_entry(desc->list.prev, struct ar71xx_pcm_desc,
+				       list);
+			prev->NextPtr = desc->phys;
+		}
+
+		offset += desc->size;
+		desc_numb++;
+#if 1
+		printk("descriptor %d:\n\tdesc->BufPtr: 0x%08x\n\tdesc->phys: 0x%08x\n\tdesc->size: %d\n", desc_numb, desc->BufPtr, desc->phys, desc->size);
+#endif
+	} while (offset < bufsize);
+
+	printk("created %d descriptor(s)\n", desc_numb);
+
+	/* Once all the descriptors have been created, we can close the loop
+	 * by pointing from the last one to the first one */
+	desc = list_first_entry(head, struct ar71xx_pcm_desc, list);
+	prev = list_entry(head->prev, struct ar71xx_pcm_desc, list);
+	prev->NextPtr = desc->phys;
+
+	spin_unlock(&ar71xx_pcm_lock);
+
+	printk("desc: 0x%08x\nprev: 0x%08x\n", desc->BufPtr, prev->BufPtr);
+
+
+	return 0;
+}
+
+void ar71xx_mbox_dma_unmap(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct list_head *head = &rtpriv->dma_head;
+	struct ar71xx_pcm_desc *desc, *n;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry_safe(desc, n, head, list) {
+		list_del(&desc->list);
+		dma_pool_free(ar71xx_pcm_cache, desc, desc->phys);
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+
+	return;
+}
+
+int ar71xx_mbox_dma_init(struct device *dev)
+{
+	int ret = 0;
+
+	/* Allocate a DMA pool to store the MBOX descriptor */
+	ar71xx_pcm_cache = dma_pool_create("ar71xx_pcm_pool", dev,
+					 sizeof(struct ar71xx_pcm_desc), 4, 0);
+	if (!ar71xx_pcm_cache)
+		ret = -ENOMEM;
+
+	return ret;
+}
+
+void ar71xx_mbox_dma_exit(void)
+{
+	dma_pool_destroy(ar71xx_pcm_cache);
+	ar71xx_pcm_cache = NULL;
+}
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-pcm.c
@@ -0,0 +1,654 @@
+/*
+ * ath-pcm.c -- ALSA PCM interface for the QCA Wasp based audio interface
+ *
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/dma-mapping.h> //dma api (eg. dma_alloc_coherent(..)
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+//#include <asm/mach-ath79/irq.h> //TODO test if available here
+
+//#include "ar71xx_regs.h" //TODO currently registers in ar71xx-i2s.h maybe move to ar71xx-pcm.h
+//#include "ath79.h" // naaaa
+
+#include <linux/mm.h>
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#include "ar71xx-pcm.h"
+//#include "ar71xx-i2s.h"
+
+
+#define BUFFER_BYTES_MAX 16 * 4095 * 16
+#define PERIOD_BYTES_MIN 64
+
+
+
+static struct snd_pcm_hardware ar71xx_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
+	.formats = SNDRV_PCM_FMTBIT_S8 |
+			SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_BE | SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = SNDRV_PCM_RATE_22050 |
+			SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000 |
+			SNDRV_PCM_RATE_88200 |
+			SNDRV_PCM_RATE_96000,
+	.rate_min = 22050,
+	.rate_max = 96000,
+	.channels_min = 2,
+	.channels_max = 2,
+	/* These numbers are empirical. As the DMA engine is descriptor base
+	 * the only real limitation we have is the amount of RAM.
+	 * Ideally, we'd need to find the best tradeoff between number of descs
+	 * and CPU load */
+
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = 4095,
+	.periods_min = 16,
+	.periods_max = 256,
+	.fifo_size = 0,
+};
+
+static irqreturn_t ar71xx_pcm_interrupt(int irq, void *dev_id)
+{
+	uint32_t status;
+	struct ar71xx_pcm_pltfm_priv *prdata = dev_id;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	unsigned int period_bytes;
+
+
+#if 0
+	//XXX look for error interrupts
+	const uint32_t mystatus = AR9331_MBOX_INT_ENABLE_TX_DMA_EOM_COMPLETE |
+				AR9331_MBOX_INT_ENABLE_TX_OVERFLOW |
+				AR9331_MBOX_INT_ENABLE_RX_UNDERFLOW |
+				AR9331_MBOX_INT_ENABLE_TX_NOT_EMPTY |
+				AR9331_MBOX_INT_ENABLE_RX_NOT_FULL;
+#endif
+
+	regmap_read(prdata->mbox_regmap, AR9331_MBOX_INT_STATUS, &status);
+#if 0
+	printk("###interrupt###\tstatus: %08x\n", status);
+#endif
+
+	/*
+	 * 1 Frame = channels * bitnumber
+	 * eg: 2 chnls * 16 Bit = 4 Bytes
+	 *	
+	 * period: number of frames between HW interrupts
+	 */
+
+	/* RX DMA is enabled */
+	if(status & AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE) {
+		unsigned int played_size;
+		rtpriv = prdata->playback->runtime->private_data;
+
+		/* Store the last played buffer in the runtime priv struct */
+		rtpriv->last_played = ar71xx_pcm_get_last_played(rtpriv);
+		period_bytes = snd_pcm_lib_period_bytes(prdata->playback);
+
+		played_size = ar71xx_pcm_set_own_bits(rtpriv);
+
+#if 0 
+		printk("period_bytes: %d, played_size: %d\n", period_bytes, played_size);
+#endif
+
+		if(played_size > period_bytes)
+			printk("Played more than one period bytes played: %d\n",played_size);
+	
+		rtpriv->elapsed_size += played_size;
+		ar71xx_mbox_interrupt_ack(AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE, prdata);
+		if(rtpriv->elapsed_size >= period_bytes)
+		{
+			rtpriv->elapsed_size %= period_bytes;
+			snd_pcm_period_elapsed(prdata->playback);
+		}
+
+		if (rtpriv->last_played == NULL) {
+			printk("BUG: ISR called but no played buf found\n");
+			goto ack;
+		}
+	} 
+
+	if(status & AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE) {
+		rtpriv = prdata->capture->runtime->private_data;
+
+		/* Store the last played buffer in the runtime priv struct */
+		rtpriv->last_played = ar71xx_pcm_get_last_played(rtpriv);
+		ar71xx_pcm_set_own_bits(rtpriv);
+		ar71xx_mbox_interrupt_ack(AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE, prdata);
+
+		if (rtpriv->last_played == NULL) {
+			printk("BUG: ISR called but no rec buf found\n");
+			goto ack;
+		}
+		snd_pcm_period_elapsed(prdata->capture);
+	}
+#if 0
+	if(status & mystatus) {
+		//printk("***interrupt error***, value:%08x\n", status);
+		ar71xx_mbox_interrupt_ack(status, prdata);
+	}
+#endif
+
+ack:
+	return IRQ_HANDLED;
+}
+
+static int ar71xx_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *runtime = ss->private_data;
+	struct snd_soc_platform *platform = runtime->platform;
+	struct ar71xx_pcm_pltfm_priv *prdata = snd_soc_platform_get_drvdata(platform);
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	int err;
+
+	printk("in pcm_open()\n");
+
+
+#if 1
+	/* setup new platform private struct (input and output pcm substream) */
+	//XXX 
+	//prdata = kzalloc(sizeof(struct ar71xx_pcm_pltfm_priv), GFP_KERNEL);
+	//if (prdata == NULL)
+	//	return -ENOMEM;
+	//snd_soc_platform_set_drvdata(platform, prdata);
+
+	if (!prdata->irq_en) {
+		err = request_irq(ATH79_MISC_IRQ(7), ar71xx_pcm_interrupt, 0,
+				  "ar71xx-pcm-interrupt", prdata);
+
+		if (err) {
+			//TODO kfree needed?
+			//kfree(prdata);
+			return -EBUSY;
+		}
+		prdata->irq_en = true;
+		printk("requested interrupt\n");
+	}
+
+	//snd_soc_platform_set_drvdata(platform, prdata);
+//	}
+#endif
+
+	/* setup substream */
+	if (ss->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prdata->playback = ss;
+	} else {
+		prdata->capture = ss;
+	}
+
+	/* Allocate/Initialize the buffer linked list head */
+	rtpriv = kmalloc(sizeof(*rtpriv), GFP_KERNEL);
+	if (!rtpriv) {
+		return -ENOMEM;
+	}
+#if 0
+	snd_printd("%s: 0x%xB allocated at 0x%08x\n",
+	       __FUNCTION__, sizeof(*rtpriv), (u32) rtpriv);
+#endif
+	printk("%s: 0x%xB allocated at 0x%08x\n",
+	       __FUNCTION__, sizeof(*rtpriv), (u32) rtpriv);
+
+	ss->runtime->private_data = rtpriv;
+	rtpriv->last_played = NULL;
+	INIT_LIST_HEAD(&rtpriv->dma_head);
+	
+	/* TODO could be in previous if sequence ?? */
+	if(ss->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtpriv->direction = SNDRV_PCM_STREAM_PLAYBACK;
+	else
+		rtpriv->direction = SNDRV_PCM_STREAM_CAPTURE;
+
+	snd_soc_set_runtime_hwparams(ss, &ar71xx_pcm_hardware);
+
+	return 0;
+}
+
+static int ar71xx_pcm_close(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *runtime = ss->private_data;
+	struct snd_soc_platform *platform = runtime->platform;
+	struct ar71xx_pcm_pltfm_priv *prdata = snd_soc_platform_get_drvdata(platform);
+	struct ar71xx_pcm_rt_priv *rtpriv;
+
+	printk("in pcm_close\n");
+
+	if (!prdata)
+		return 0;
+
+	if (ss->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prdata->playback = NULL;
+	} else {
+		prdata->capture = NULL;
+	}
+
+	if (!prdata->playback && !prdata->capture) {
+		free_irq(ATH79_MISC_IRQ(7), prdata);
+		kfree(prdata);
+		snd_soc_platform_set_drvdata(platform, NULL);
+	}
+	rtpriv = ss->runtime->private_data;
+	kfree(rtpriv);
+
+	return 0;
+}
+
+static int ar71xx_pcm_hw_params(struct snd_pcm_substream *ss,
+			      struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	int ret;
+	unsigned int buffer_size, period_size, sample_size, sample_rate, frames, channels;
+
+	printk("in pcm_hw_params\n");
+
+	// Does this routine need to handle new clock changes in the hw_params?
+	rtpriv = runtime->private_data;
+
+	ret = ar71xx_mbox_dma_map(rtpriv, ss->dma_buffer.addr,
+		params_period_bytes(hw_params), params_buffer_bytes(hw_params));
+
+	if(ret < 0)
+		return ret;
+	
+	//TODO what for??
+	period_size = params_period_bytes(hw_params);
+	sample_size = snd_pcm_format_size(params_format(hw_params), 1);
+	buffer_size = params_buffer_bytes(hw_params);
+	sample_rate = params_rate(hw_params);
+	channels = params_channels(hw_params);
+	frames = period_size / (sample_size * channels);
+
+	printk("parameters:\nperiod_size\t->\t%d\nsample_size\t->\t%d\nsample_rate\t->\t%d\nchannels\t\t->\t%d\nframes\t\t->\t%d\nbuffer_size\t->\t%d\n", period_size, sample_size, sample_rate, channels, frames, buffer_size);
+
+/* 	When we disbale the DMA engine, it could be just at the start of a descriptor.
+	Hence calculate the longest time the DMA engine could be grabbing bytes for to
+	Make sure we do not unmap the memory before the DMA is complete.
+	Add 10 mSec of margin. This value will be used in ath79_mbox_dma_stop */
+
+	rtpriv->delay_time = (frames * 1000)/sample_rate + 10;
+
+
+	snd_pcm_set_runtime_buffer(ss, &ss->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(hw_params);
+
+	return 1;
+}
+
+static int ar71xx_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	
+	printk("in pcm_hw_free -> %s\n", ss->name);
+
+	rtpriv = runtime->private_data;
+	ar71xx_mbox_dma_unmap(rtpriv);
+	snd_pcm_set_runtime_buffer(ss, NULL);
+	return 0;
+}
+
+static int ar71xx_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+	struct snd_soc_dai *cpu_dai;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+
+	struct snd_soc_platform *platform = rtd->platform;
+	struct ar71xx_pcm_pltfm_priv *dev = dev_get_drvdata(platform->dev);
+
+
+	printk("in pcm_prepare, dev=%p, dev->mbox_regmap %p, dev->reset_regmap %p\n", 
+		dev, dev->mbox_regmap, dev->reset_regmap);
+
+
+	rtpriv = runtime->private_data;
+	cpu_dai = rtd->cpu_dai;
+
+	/* When setup the first stream should reset the DMA MBOX controller */
+	if(cpu_dai->active == 1) {
+		printk("cpu_dai->active == 1; doing and mbox_dma_reset\n");
+		ar71xx_mbox_dma_reset(dev);
+	}
+
+	ar71xx_mbox_dma_prepare(rtpriv, dev);
+
+	ar71xx_pcm_set_own_bits(rtpriv);
+	rtpriv->last_played = NULL;
+
+	return 0;
+}
+
+static int ar71xx_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	struct ar71xx_pcm_rt_priv *rtpriv = ss->runtime->private_data;
+
+	//TODO device??
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct ar71xx_pcm_pltfm_priv *dev = dev_get_drvdata(platform->dev);
+
+	printk("in pcm_trigger, dev=%p\n", dev);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ar71xx_mbox_dma_start(rtpriv, dev);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ar71xx_mbox_dma_stop(rtpriv, dev);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t ar71xx_pcm_pointer(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	snd_pcm_uframes_t ret = 0;
+	snd_pcm_uframes_t ret_frames = 0;
+
+
+	rtpriv = runtime->private_data;
+
+	if(rtpriv->last_played == NULL)
+		ret = 0;
+	else
+		ret = rtpriv->last_played->BufPtr - runtime->dma_addr;
+
+	ret_frames = bytes_to_frames(runtime, ret);
+
+#if 0
+	printk("called pcm_pointer, ret: %d, ret_frames: %d\n", ret, ret_frames);
+#endif
+	
+	return ret;
+}
+
+static int ar71xx_pcm_mmap(struct snd_pcm_substream *ss, struct vm_area_struct *vma)
+{
+	printk("in pcm_mmap\n");
+
+	return remap_pfn_range(vma, vma->vm_start,
+			ss->dma_buffer.addr >> PAGE_SHIFT,
+			vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
+static struct snd_pcm_ops ar71xx_pcm_ops = {
+	.open		= ar71xx_pcm_open,
+	.close		= ar71xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ar71xx_pcm_hw_params,
+	.hw_free	= ar71xx_pcm_hw_free,
+	.prepare	= ar71xx_pcm_prepare,
+	.trigger	= ar71xx_pcm_trigger,
+	.pointer	= ar71xx_pcm_pointer,
+	.mmap		= ar71xx_pcm_mmap,
+};
+
+static void ar71xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *ss;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		ss = pcm->streams[stream].substream;
+		if (!ss)
+			continue;
+		buf = &ss->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(NULL, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+
+	ar71xx_mbox_dma_exit();
+}
+
+static int ar71xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *ss = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &ss->dma_buffer;
+
+	printk(KERN_NOTICE "%s: allocate %8s stream\n", __FUNCTION__,
+		stream == SNDRV_PCM_STREAM_CAPTURE ? "capture" : "playback" );
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->bytes = ar71xx_pcm_hardware.buffer_bytes_max;
+
+	buf->area = dma_alloc_coherent(NULL, buf->bytes,
+					   &buf->addr, GFP_DMA);
+	if (!buf->area)
+		return -ENOMEM;
+
+	printk(KERN_NOTICE "%s: 0x%xB allocated at 0x%08x\n",
+		__FUNCTION__, buf->bytes, (u32) buf->area);
+
+	return 0;
+}
+
+static u64 ar71xx_pcm_dmamask = 0xffffffff;
+
+static int ar71xx_soc_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	printk("in soc_pcm_new\n");
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &ar71xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = ar71xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = ar71xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+	ar71xx_mbox_dma_init(rtd->platform->dev);
+
+out:
+	return ret;
+}
+
+struct snd_soc_platform_driver ar71xx_soc_platform = {
+	.ops		= &ar71xx_pcm_ops,
+	.pcm_new	= ar71xx_soc_pcm_new,
+	.pcm_free	= ar71xx_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(ar71xx_soc_platform);
+
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	/* MBOX DMA Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR9331_SLIC_MBOX_DMA_FIFO_RESET,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* Reset Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR9331_RESET_RST_RESET,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* Interrupt Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR9331_RESET_RST_MISC_INT_MASK,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+static int ar71xx_pcm_probe(struct platform_device *pdev)
+{
+	struct ar71xx_pcm_dev *dev;
+	struct ar71xx_pcm_pltfm_priv *prdata;
+
+	int ret, i;
+	struct regmap *regmap[3];
+	struct resource *mem[3];
+
+	printk("in pcm probe\n");
+
+
+	/* Request ioarea */
+	for (i = 0; i < 3; i++) {
+		void __iomem *base;
+	
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base,
+					    &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "PCM probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	
+		printk("allocated regmap[%d] at %p\n", i, regmap[i]);
+	}
+
+	prdata = kzalloc(sizeof(struct ar71xx_pcm_pltfm_priv), GFP_KERNEL);
+	if (prdata == NULL)
+		return -ENOMEM;
+
+	prdata->mbox_regmap = regmap[0];
+	prdata->reset_regmap = regmap[1];
+	prdata->misc_int_regmap = regmap[2];
+
+	/* interrupt not yet enabled */
+	prdata->irq_en = false;
+
+	//snd_soc_platform_set_drvdata(platform, prdata);
+#if 0
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	dev->mbox_regmap = regmap[0];
+	dev->reset_regmap = regmap[1];
+	dev->misc_int_regmap = regmap[2];
+
+
+	/* Store the pdev */
+	dev->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, dev);
+#endif
+
+	prdata->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, prdata);
+
+	struct ar71xx_pcm_pltfm_priv *prdata_test = dev_get_drvdata(&pdev->dev);
+
+	printk("private data at %p\nprdata->mbox_regmap at %p\nprdata->reset_regmap at %p\n", prdata_test, prdata_test->mbox_regmap, prdata_test->reset_regmap);
+
+#if 0
+	/* setup new platform private struct (input and output pcm substream) */
+	prdata = devm_kzalloc(&pdev->dev, sizeof(struct ar71xx_pcm_pltfm_priv), GFP_KERNEL);
+	if (prdata == NULL)
+		return -ENOMEM;
+
+	//TODO not best practice to request irq in probe but i have currently no better solution
+	err = request_irq(ATH79_MISC_IRQ(7), ar71xx_pcm_interrupt, 0,
+			  "ar71xx-pcm-interrupt", prdata);
+	if (err) {
+		kfree(prdata);
+		return -EBUSY;
+	}
+
+	prdata->mbox_regmap = regmap[0];
+	prdata->reset_regmap = regmap[1];
+
+	snd_soc_platform_set_drvdata(platform, prdata);
+	// end of XXX
+#endif
+
+	ret = snd_soc_register_platform(&pdev->dev, &ar71xx_soc_platform);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register platform: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ar71xx_pcm_remove(struct platform_device *pdev)
+{
+	printk("in pcm remove\n");
+
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_pcm_driver = {
+	.probe 		= ar71xx_pcm_probe,
+	.remove 	= __exit_p(ar71xx_pcm_remove),
+	.driver 	= {
+		.name 	= "ar71xx-pcm",
+		.owner 	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_pcm_driver);
+
+MODULE_ALIAS("platform:ar71xx-pcm");
+MODULE_DESCRIPTION("QCA Audio PCM DMA module");
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-pcm.h
@@ -0,0 +1,196 @@
+#ifndef AR71XX_PCM_H_
+#define AR71XX_PCM_H_
+
+#include <linux/sound.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+
+
+/* MBOX REGISTERS */
+#define AR9331_MBOX_DMA_POLICY			0x10
+#define AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE	0x18
+#define AR9331_MBOX_DMA_RX_CONTROL		0x1c
+#define AR9331_MBOX_DMA_TX_DESCRIPTOR_BASE	0x20
+#define AR9331_MBOX_DMA_TX_CONTROL		0x24
+#define AR9331_MBOX_INT_STATUS			0x44
+#define AR9331_MBOX_INT_ENABLE			0x4c
+#define AR9331_MBOX_DMA_FIFO_RESET		0x58
+#define AR9331_SLIC_MBOX_DMA_FIFO_RESET		0x5C
+
+#define AR9331_MBOX_DMA_CONTROL_STOP			BIT(0)
+#define AR9331_MBOX_DMA_CONTROL_START			BIT(1)
+#define AR9331_MBOX_DMA_CONTROL_RESUME			BIT(2)
+
+#define AR9331_MBOX_DMA_POLICY_RX_QUANTUM		BIT(1) 
+#define AR9331_MBOX_DMA_POLICY_TX_QUANTUM		BIT(3)
+#define AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(v)	(((v) & 0xf) << 4)
+
+#define AR9331_MBOX_DMA_FIFO_RESET_TX_INIT		BIT(2)
+#define AR9331_MBOX_DMA_FIFO_RESET_RX_INIT		BIT(0)
+
+#define AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE		BIT(10)
+#define AR9331_MBOX_INT_ENABLE_TX_DMA_EOM_COMPLETE	BIT(8)
+#define AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE		BIT(6)
+#define AR9331_MBOX_INT_ENABLE_TX_OVERFLOW		BIT(5)
+#define AR9331_MBOX_INT_ENABLE_RX_UNDERFLOW		BIT(4)
+#define AR9331_MBOX_INT_ENABLE_TX_NOT_EMPTY		BIT(2)
+#define AR9331_MBOX_INT_ENABLE_RX_NOT_FULL		BIT(0)
+
+/* Reset Registers */
+#define AR9331_RESET_RST_RESET				0x00
+
+#define AR9331_RESET_RST_RESET_MBOX			BIT(1)
+#define AR9331_RESET_RST_RESET_I2S			BIT(0)
+
+//XXX
+#define MISC_INT_DMA					BIT(7)
+
+
+/* interrupts */
+#define AR9331_RESET_RST_MISC_INT_STATUS		0x00
+#define AR9331_RESET_RST_MISC_INT_MASK			0x04
+
+#define AR9331_RESET_RST_MISC_INT_MASK_MBOX		BIT(7)
+
+
+
+#define ATH79_MISC_IRQ_BASE	8
+#define ATH79_MISC_IRQ(_x)	(ATH79_MISC_IRQ_BASE + (_x))
+
+//TODO find extern spinlock
+extern spinlock_t ar71xx_pcm_lock;
+
+struct ar71xx_pcm_dev {
+	struct device		*dev;
+
+	struct regmap 		*mbox_regmap;
+	struct regmap		*reset_regmap;
+	struct regmap		*misc_int_regmap;
+};
+
+
+struct ar71xx_pcm_desc {
+	unsigned int	OWN	:  1,    /* bit 31 */
+			EOM	:  1,    /* bit 30 */
+			rsvd1	:  6,    /* bit 29-24 */
+			size	: 12,    /* bit 23-12 */
+			length	: 12,    /* bit 11-00 */
+			rsvd2	:  4,    /* bit 31-28 */
+			BufPtr	: 28,    /* bit 27-00 */
+			rsvd3	:  4,    /* bit 31-28 */
+			NextPtr	: 28;    /* bit 27-00 */
+
+	unsigned int Va[6];
+	unsigned int Ua[6];
+	unsigned int Ca[6];
+	unsigned int Vb[6];
+	unsigned int Ub[6];
+	unsigned int Cb[6];
+
+	/* Software specific data
+	 * These data are not taken into account by the HW */
+	struct list_head list; /* List linking all the buffer in virt@ space */
+	dma_addr_t phys; /* Physical address of the descriptor */
+};
+
+struct ar71xx_pcm_rt_priv {
+	struct list_head dma_head;
+	struct ar71xx_pcm_desc *last_played;
+	unsigned int elapsed_size;
+	unsigned int delay_time;
+	int direction;
+};
+
+/* Replaces struct ath_i2s_softc */
+struct ar71xx_pcm_pltfm_priv {
+	struct snd_pcm_substream *playback;
+	struct snd_pcm_substream *capture;
+
+	//ar71xx_pcm_dev
+	struct device		*dev;
+
+	struct regmap 		*mbox_regmap;
+	struct regmap		*reset_regmap;
+	struct regmap		*misc_int_regmap;
+
+	bool irq_en;
+};
+
+
+
+/* platform data */
+extern struct snd_soc_platform_driver ar71xx_soc_platform;
+
+/* mbox functions */
+void ar71xx_mbox_interrupt_ack(u32 mask, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_start(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_stop(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_prepare(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+int ar71xx_mbox_dma_map(struct ar71xx_pcm_rt_priv *rtpriv, dma_addr_t baseaddr, int period_bytes, int bufsize);
+void ar71xx_mbox_dma_unmap(struct ar71xx_pcm_rt_priv *rtpriv);
+int ar71xx_mbox_dma_init(struct device *dev);
+void ar71xx_mbox_dma_exit(void);
+void ar71xx_mbox_dma_reset(struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_rx_resume(struct ar71xx_pcm_pltfm_priv *dev);
+
+
+/* sets OWN bits in descriptor to 1 and returns overall size of played data */
+static inline unsigned int ar71xx_pcm_set_own_bits(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc;
+	unsigned int size_played = 0;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 0) {
+			desc->OWN = 1;
+			size_played += desc->size;
+		}
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+	return size_played;
+}
+
+static inline void ar71xx_pcm_clear_own_bits(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 1) {
+			desc->OWN = 0;
+		}
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+}
+
+static inline struct ar71xx_pcm_desc *ar71xx_pcm_get_last_played(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc, *prev;
+
+	//XXX changed because when returning NULL, spin lock wasn't unlocked
+	//TODO save memory, delete this struct
+	//struct ar71xx_pcm_desc *ret = NULL;
+
+	spin_lock(&ar71xx_pcm_lock);
+	prev = list_entry(rtpriv->dma_head.prev, struct ar71xx_pcm_desc, list);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 1 && prev->OWN == 0) {
+			return desc;
+			//ret = desc;
+			//goto out;
+		}
+		prev = desc;
+	}
+
+//out:
+	spin_unlock(&ar71xx_pcm_lock);
+
+	/* If we didn't find the last played buffer, return NULL */
+	return NULL;
+	//return ret;
+}
+
+
+#endif /* AR71XX_PCM_H_ */
--- /dev/null
+++ b/arch/mips/ath79/dev-pcm.c
@@ -0,0 +1,23 @@
+/*
+ *  Atheros AR9331 PCM Audio support
+ *
+ *  Copyright (C) 2014 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-pcm.h"
+
+int __init ath79_register_pcm(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		pr_debug("Unable to register platform devices '%s' %d\n",
+		         pdev->name, ret);
+
+	return ret;
+}
--- /dev/null
+++ b/arch/mips/ath79/dev-pcm.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR9331 PCM Audio support
+ *
+ *  Copyright (C) 2014 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_PCM_H
+#define _ATH79_DEV_PCM_H
+
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+
+int __init ath79_register_pcm(struct platform_device *pdev);
+
+
+#endif /* _ATH79_DEV_PCM_H */
