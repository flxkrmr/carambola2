--- /dev/null
+++ b/sound/soc/ar71xx/Kconfig
@@ -0,0 +1,4 @@
+config SND_AR71XX_SOC_I2S
+	tristate "SoC Aduio support for the AR71XX I2S Module"
+	help
+	  Say Y or M...
--- /dev/null
+++ b/sound/soc/ar71xx/Makefile
@@ -0,0 +1,4 @@
+# AR71XX Platform Support
+snd-soc-ar71xx-i2s-objs := ar71xx-i2s.o
+
+obj-$(CONFIG_SND_AR71XX_SOC_I2S) += snd-soc-ar71xx-i2s.o
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.c
@@ -0,0 +1,346 @@
+/*
+ * ALSA SoC I2S Audio Layer for AR9331
+ *
+ */
+
+/* GPIO function registers */
+#define AR71XX_GPIO_FUNCTION			0x18040028
+#define AR71XX_GPIO_FUNCTION_SPDIF2TCK		BIT(31)
+#define AR71XX_GPIO_FUNCTION_SPDIF_EN		BIT(30)
+#define AR71XX_GPIO_FUNCTION_I2SO_22_18_EN	BIT(29)
+#define AR71XX_GPIO_FUNCTION_I2S_MCKEN		BIT(27)
+#define AR71XX_GPIO_FUNCTION_I2SO_EN		BIT(26)
+
+/* I2S registers */
+#define AR71XX_I2S_BASE				0x180B0000
+#define AR71XX_I2S_STEREO0_CONFIG		((AR71XX_I2S_BASE) + 0x00)
+#define AR71XX_I2S_STEREO0_VOLUME		((AR71XX_I2S_BASE) + 0x04)
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_LSB	((AR71XX_I2S_BASE) + 0x0C)
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_MSB	((AR71XX_I2S_BASE) + 0x10)
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_LSB	((AR71XX_I2S_BASE) + 0x14)
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_MSB	((AR71XX_I2S_BASE) + 0x18)
+#define AR71XX_I2S_STEREO0_CLK_DIV		((AR71XX_I2S_BASE) + 0x1C)
+
+/* STEREO0_CONFIG masks */
+#define AR71XX_I2S_DIV_BYPASS			BIT(25)
+#define AR71XX_I2S_AUDIO_CLOCK_SEL		BIT(24)
+#define AR71XX_I2S_SPDIF_ENABLE			BIT(23)
+#define AR71XX_I2S_REFCLK_SEL			BIT(22)
+#define AR71XX_I2S_ENABLE			BIT(21)
+#define AR71XX_I2S_MIC_RESET			BIT(20)
+#define AR71XX_I2S_RESET			BIT(19)
+#define AR71XX_I2S_I2S_DELAY			BIT(18)
+#define AR71XX_I2S_PCM_SWAP			BIT(17)
+#define AR71XX_I2S_MIC_WORD_SIZE		BIT(16)
+#define AR71XX_I2S_SETERO_MONO 			//15:14
+#define AR71XX_I2S_DATA_WORD_SIZE		//13:12
+#define AR71XX_I2S_I2S_WORD_SIZE		BIT(11)
+#define AR71XX_I2S_MCK_SEL			BIT(10)
+#define AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE	BIT(9)
+#define AR71XX_I2S_MASTER			BIT(8)
+#define AR71XX_I2S_POSEDGE			//7:0
+
+/* STEREO0_VOLUME masks */
+#define AR71XX_I2S_CHANNEL1(v)			((v) << 8)
+#define AR71XX_I2S_CHANNEL0(v)			(v)
+
+/* Tx and Rx Counter masks */
+#define AR71XX_I2S_SAMPLE_COUNTER_CH0		(0xFFFF)
+#define AR71XX_I2S_SAMPLE_COUNTER_CH1		(0xFFFF << 16)
+
+/* STEREO_CLOCK_DIV masks */
+#define AR71XX_I2S_DIV_INT(v)			((v) << 16)
+#define AR71XX_I2S_DIV_FRAC(v)			(v)
+
+
+#if 0
+//XXX for testing
+/* GPIO registers */
+#define AR71XX_GPIO_BASE			(0x18040000)
+#define AR71XX_GPIO_OE				((AR71XX_GPIO_BASE) + 0x00)
+#define AR71XX_GPIO_IN				((AR71XX_GPIO_BASE) + 0x04)
+#define AR71XX_GPIO_OUT				((AR71XX_GPIO_BASE) + 0x08)
+#define AR71XX_GPIO_SET				((AR71XX_GPIO_BASE) + 0x0C)
+#define AR71XX_GPIO_CLEAR			((AR71XX_GPIO_BASE) + 0x10)
+#define AR71XX_GPIO(v)				(1 << (v))
+#define AR71XX_TEST_GPIO			23
+#define AR71XX_I2S_DRIVER_MAJ_NUM		240
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+//#include <linux/device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+
+struct ar71xx_i2s_dev {
+	struct device				*dev;
+	struct snd_dmaengine_dai_dma_data	dma_data[2];
+	unsigned int 				fmt;
+	unsigned int 				bclk_ratio;
+
+	struct regmap *i2s_regmap;
+	struct regmap *gpio_regmap;
+	//struct regmap *clk_regmap;
+};
+
+static int ar71xx_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK];
+	dai->capture_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE];
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops ar71xx_i2s_dai_ops = {
+	.startup	= ar71xx_i2s_startup,
+	.shutdown	= ar71xx_i2s_shutdown,
+	.prepare	= ar71xx_i2s_prepare,
+	.trigger	= ar71xx_i2s_trigger,
+	.hw_params	= ar71xx_i2s_hw_params,
+	.set_fmt	= ar71xx_i2s_set_dai_fmt,
+	.set_bclk_ratio	= ar71xx_i2s_set_dai_bclk_ratio
+};
+
+static struct snd_soc_dai_driver ar71xx_i2s_dai = {
+	.name	= "ar71xx-i2s",
+	.probe	= ar71xx_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_8000_192000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE 
+				| SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_8000_192000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.ops = &ar71xx_i2s_dai_ops, 
+	.symmetric_rates = 1
+};
+
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_I2S_STEREO0_CLK_DIV - AR71XX_I2S_BASE,
+		//.precious_reg = ar71xx_i2s_precious_reg;
+		//.volatile_reg = ar71xx_i2s_volatile_reg;
+		.cache_type = REGCACHE_RBTREE,
+	},
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+static const struct snd_soc_component_driver ar71xx_i2s_component = {
+	.name		= "ar71xx-i2s-comp",
+};
+
+
+static int ar71xx_i2s_probe (struct platform_device *pdev)
+{
+	struct ar71xx_i2s_dev *dev;
+	int i;
+	int ret;
+	struct regmap *regmap[2];
+	struct resource *mem[2];
+
+	for (i = 0; i < 2; i++) {
+		void __iomem *base;
+
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base)) 
+			return PTR_ERR(base);
+		
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base, 
+		                                  &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "I2S probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	}
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev),
+			   GFP_KERNEL);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	dev->i2s_regmap = regmap[0];
+	dev->gpio_regmap = regmap[1];
+
+#if 0
+	/* Set the DMA address */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	/* Set the DREQ */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].slave_id =
+		BCM2708_DMA_DREQ_PCM_TX;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].slave_id =
+		BCM2708_DMA_DREQ_PCM_RX;
+
+	/* Set the bus width */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	/* Set burst */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 2;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 2;
+#endif
+
+	/* BCLK ratio - use default */
+	dev->bclk_ratio = 0;
+
+	/* Store the pdev */
+	dev->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, dev);
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&ar71xx_i2s_component, &ar71xx_i2s_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev,
+				&ar71xx_dmaengine_pcm_config,
+				SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		snd_soc_unregister_component(&pdev->dev);
+		return ret;
+	}
+
+
+
+	return 0;
+}
+
+static int ar71xx_i2s_remove (struct platform_device *pdev)
+{
+#if 0
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+#endif
+
+	return 0;
+}
+
+
+static struct platform_driver ar71xx_i2s_driver = {
+	.probe		= ar71xx_i2s_probe,
+	.remove		= ar71xx_i2s_remove,
+	.driver		= {
+		.name	= "ar71xx-i2s",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_i2s_driver);
+
+#if 0
+
+/* virtual register address */
+//XXX gpio test
+static uint32_t *gpio_oe;
+static uint32_t *gpio_out;
+static uint32_t *gpio_set;
+static uint32_t *gpio_clear;
+
+//XXX gpio test
+void setup_gpio(void)
+{
+	uint32_t val = 0;
+	uint32_t tmp_val;
+
+	//enable output pin
+	val = *gpio_oe;
+	val |= AR71XX_GPIO(AR71XX_TEST_GPIO);
+	*gpio_oe = val;
+	
+	//set pin
+	*gpio_clear = AR71XX_GPIO(AR71XX_TEST_GPIO);
+
+	//print output value register
+	tmp_val = *gpio_out; 
+	printk("GPIO_OUT: 0x%02X\n", tmp_val);
+}
+
+static struct file_operations fops = {
+	.owner = THIS_MODULE,
+//	.read = driver_read,
+//	.open = driver_open,
+//	.release = driver_close,
+};
+
+
+static int __init mod_init(void)
+{
+	if (register_chrdev(AR71XX_I2S_DRIVER_MAJ_NUM, "I2S Driver", &fops) != 0) {
+		printk("Initializing I2S Driver failed\n");
+		return -EIO;
+	}
+
+	printk("initialized I2S Driver\n");
+
+	/* request i/o remapping */
+	// XXX gpio test 
+	// TODO test sizes!
+	gpio_oe = ioremap(AR71XX_GPIO_OE, 1);
+	gpio_out = ioremap(AR71XX_GPIO_OUT, 1);
+	gpio_set = ioremap(AR71XX_GPIO_SET, 1);
+	gpio_clear = ioremap(AR71XX_GPIO_CLEAR, 1);
+
+	setup_gpio();
+
+	return 0;
+}
+
+static void __exit mod_exit(void)
+{
+	iounmap(gpio_oe);	
+	iounmap(gpio_out);	
+	iounmap(gpio_set);	
+	iounmap(gpio_clear);	
+
+	unregister_chrdev(AR71XX_I2S_DRIVER_MAJ_NUM, "I2S Driver");
+
+	printk("exited I2S Driver\n");
+}
+
+module_init (mod_init);
+module_exit (mod_exit);
+#endif
+
+//TODO MODULE_ALIAS ???
+MODULE_AUTHOR("Felix Kramer");
+MODULE_LICENSE("GPL v2"); 
+MODULE_DESCRIPTION("AR71XX I2S Interface");
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_GENERIC_DMAENGINE_PCM
 	select SND_SOC_DMAENGINE_PCM
 
 # All the supported SoCs
+source "sound/soc/ar71xx/Kconfig"
 source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/blackfin/Kconfig"
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -12,6 +12,7 @@ endif
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/
 obj-$(CONFIG_SND_SOC)	+= generic/
+obj-$(CONFIG_SND_SOC)	+= ar71xx/
 obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= blackfin/
