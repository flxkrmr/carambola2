--- /dev/null
+++ b/sound/soc/ar71xx/Kconfig
@@ -0,0 +1,14 @@
+config SND_SOC_AR71XX_I2S
+	tristate "SoC Audio support for the AR71XX I2S Module"
+	select REGMAP_MMIO
+	select SND_SOC_DMAENGINE_PCM
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M...
+
+config SND_SOC_AR71XX_HIFIBERRY_DAC
+	tristate "Hifiberry DAC Machine Driver"
+	depends on SND_SOC_AR71XX_I2S
+	select SND_SOC_PCM5102A
+	help
+	  Say Y or M...
--- /dev/null
+++ b/sound/soc/ar71xx/Makefile
@@ -0,0 +1,9 @@
+# AR71XX Platform Support
+snd-soc-ar71xx-i2s-objs := ar71xx-i2s.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_I2S) += snd-soc-ar71xx-i2s.o
+
+# AR71XX Machine Support
+snd-soc-ar71xx-hifiberry-dac-objs := hifiberry_dac.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) += snd-soc-ar71xx-hifiberry-dac.o
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.c
@@ -0,0 +1,998 @@
+/*
+ * ALSA SoC I2S Audio Layer for Broadcom AR71XX SoC
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * Based on
+ *	Raspberry Pi PCM I2S ALSA Driver
+ *	Copyright (c) by Phil Poole 2013
+ *
+ *	ALSA SoC I2S (McBSP) Audio Layer for TI DAVINCI processor
+ *      Vladimir Barinov, <vbarinov@embeddedalley.com>
+ *	Copyright (C) 2007 MontaVista Software, Inc., <source@mvista.com>
+ *
+ *	OMAP ALSA SoC DAI driver using McBSP port
+ *	Copyright (C) 2008 Nokia Corporation
+ *	Contact: Jarkko Nikula <jarkko.nikula@bitmer.com>
+ *		 Peter Ujfalusi <peter.ujfalusi@ti.com>
+ *
+ *	Freescale SSI ALSA SoC Digital Audio Interface (DAI) driver
+ *	Author: Timur Tabi <timur@freescale.com>
+ *	Copyright 2007-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include "ar71xx-i2s.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+
+#if 0
+
+/* Clock registers */
+#define AR71XX_CLK_PCMCTL_REG  0x00
+#define AR71XX_CLK_PCMDIV_REG  0x04
+
+/* Clock register settings */
+#define AR71XX_CLK_PASSWD	(0x5a000000)
+#define AR71XX_CLK_PASSWD_MASK	(0xff000000)
+#define AR71XX_CLK_MASH(v)	((v) << 9)
+#define AR71XX_CLK_FLIP		BIT(8)
+#define AR71XX_CLK_BUSY		BIT(7)
+#define AR71XX_CLK_KILL		BIT(5)
+#define AR71XX_CLK_ENAB		BIT(4)
+#define AR71XX_CLK_SRC(v)	(v)
+
+#define AR71XX_CLK_SHIFT		(12)
+#define AR71XX_CLK_DIVI(v)		((v) << AR71XX_CLK_SHIFT)
+#define AR71XX_CLK_DIVF(v)		(v)
+#define AR71XX_CLK_DIVF_MASK		(0xFFF)
+
+
+enum {
+	AR71XX_CLK_MASH_0 = 0,
+	AR71XX_CLK_MASH_1,
+	AR71XX_CLK_MASH_2,
+	AR71XX_CLK_MASH_3,
+};
+#endif
+
+enum {
+	AR71XX_CLK_SRC_CPU = 0,
+	AR71XX_CLK_SRC_OSC,
+};
+
+
+static const unsigned int ar71xx_clk_freq[AR71XX_CLK_SRC_OSC+1] = {
+	[AR71XX_CLK_SRC_CPU]		= 400000000,
+	[AR71XX_CLK_SRC_OSC]		= 176000000,
+};
+
+/* GPIOs for Regmap testing */
+#define AR71XX_GPIO_OE			0x00
+#define AR71XX_GPIO_SET			0x0c
+#define AR71XX_GPIO_CLEAR		0x10
+
+#define AR71XX_GPIO_PIN(v)		(1 << (v))
+
+
+/* GPIO function registers */
+#define AR71XX_GPIO_FUNCTION			0x28
+#define AR71XX_GPIO_FUNCTION_SPDIF2TCK		BIT(31)
+#define AR71XX_GPIO_FUNCTION_SPDIF_EN		BIT(30)
+#define AR71XX_GPIO_FUNCTION_I2SO_22_18_EN	BIT(29)
+#define AR71XX_GPIO_FUNCTION_I2S_MCKEN		BIT(27)
+#define AR71XX_GPIO_FUNCTION_I2SO_EN		BIT(26)
+
+/* I2S registers */
+#define AR71XX_I2S_STEREO0_CONFIG		0x00
+#define AR71XX_I2S_STEREO0_VOLUME		0x04
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_LSB	0x0C
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_MSB	0x10
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_LSB	0x14
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_MSB	0x18
+#define AR71XX_I2S_STEREO0_CLK_DIV		0x1C
+
+/* STEREO0_CONFIG masks */
+#define AR71XX_I2S_DIV_BYPASS			BIT(25)
+#define AR71XX_I2S_AUDIO_CLOCK_SEL		BIT(24)
+#define AR71XX_I2S_SPDIF_ENABLE			BIT(23)
+#define AR71XX_I2S_REFCLK_SEL			BIT(22)
+#define AR71XX_I2S_ENABLE			BIT(21)
+#define AR71XX_I2S_MIC_RESET			BIT(20)
+#define AR71XX_I2S_RESET			BIT(19)
+#define AR71XX_I2S_I2S_DELAY			BIT(18)
+#define AR71XX_I2S_PCM_SWAP			BIT(17)
+#define AR71XX_I2S_MIC_WORD_SIZE		BIT(16)
+#define AR71XX_I2S_SETERO_MONO(v)		(((v) & 0x3) << 14)
+enum {
+	AR71XX_I2S_STEREO = 0,
+	AR71XX_I2S_MONO_CHNL0,
+	AR71XX_I2S_MONO_CHNL1,
+};
+
+#define AR71XX_I2S_DATA_WORD_SIZE(v)		(((v) & 0x3) << 12)
+enum {
+	AR71XX_I2S_DATA_WORD_8 = 0,
+	AR71XX_I2S_DATA_WORD_16,
+	AR71XX_I2S_DATA_WORD_24,
+	AR71XX_I2S_DATA_WORD_32,
+};
+
+#define AR71XX_I2S_I2S_WORD_SIZE		BIT(11)
+#define AR71XX_I2S_MCK_SEL			BIT(10)
+#define AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE	BIT(9)
+#define AR71XX_I2S_MASTER			BIT(8)
+#define AR71XX_I2S_POSEDGE(v)			((v) & 0x7f)
+#define AR71XX_I2S_POSEDGE_MASK			0x7f
+
+/* STEREO0_VOLUME masks */
+#define AR71XX_I2S_CHANNEL1(v)			((v) << 8)
+#define AR71XX_I2S_CHANNEL0(v)			(v)
+
+/* Tx and Rx Counter masks */
+#define AR71XX_I2S_SAMPLE_COUNTER_CH0		(0xFFFF)
+#define AR71XX_I2S_SAMPLE_COUNTER_CH1		(0xFFFF << 16)
+
+/* STEREO_CLOCK_DIV masks */
+#define AR71XX_I2S_CLK_SHIFT			16
+#define AR71XX_I2S_CLK_DIVF_MASK		0xffff
+#define AR71XX_I2S_DIV_INT(v)			((v) << AR71XX_I2S_CLK_SHIFT)
+#define AR71XX_I2S_DIV_FRAC(v)			(v)
+
+/* MBOX Registers */
+#define AR71XX_MBOX_FIFO_STATUS			0x08
+#define AR71XX_SLIC_MBOX_FIFO_STATUS		0x0c
+#define AR71XX_MBOX_DMA_POLICY			0x10
+#define AR71XX_SLIC_MBOX_DMA_POLICY		0x14
+#define AR71XX_MBOX_DMA_RX_DECRIPTOR_BASE	0x18
+#define AR71XX_MBOX_DMA_RX_CONTROL		0x1c
+#define AR71XX_MBOX_DMA_TX_DECRIPTOR_BASE	0x20
+#define AR71XX_MBOX_DMA_TX_CONTROL		0x24
+#define AR71XX_SLIC_MBOX_DMA_RX_DECRIPTOR_BASE	0x28
+#define AR71XX_SLIC_MBOX_DMA_RX_CONTROL		0x2c
+#define AR71XX_SLIC_MBOX_DMA_TX_DECRIPTOR_BASE	0x30
+#define AR71XX_SLIC_MBOX_DMA_TX_CONTROL		0x34
+#define AR71XX_MBOX_FRAME			0x38
+#define AR71XX_SLIC_MBOX_FRAME			0x3c
+#define AR71XX_FIFO_TIMEOUT			0x40
+#define AR71XX_MBOX_INT_STATUS			0x44
+#define AR71XX_SLIC_MBOX_INT_STATUS		0x48
+#define AR71XX_MBOX_INT_ENABLE			0x4c
+#define AR71XX_SLIC_MBOX_INT_ENABLE		0x50
+#define AR71XX_MBOX_FIFO_RESET			0x58
+#define AR71XX_SLIC_MBOX_FIFO_RESET		0x5c
+
+
+
+#if 0
+
+/* I2S registers */
+#define AR71XX_I2S_CS_A_REG		0x00
+#define AR71XX_I2S_FIFO_A_REG		0x04
+#define AR71XX_I2S_MODE_A_REG		0x08
+#define AR71XX_I2S_RXC_A_REG		0x0c
+#define AR71XX_I2S_TXC_A_REG		0x10
+#define AR71XX_I2S_DREQ_A_REG		0x14
+#define AR71XX_I2S_INTEN_A_REG	0x18
+#define AR71XX_I2S_INTSTC_A_REG	0x1c
+#define AR71XX_I2S_GRAY_REG		0x20
+
+/* I2S register settings */
+#define AR71XX_I2S_STBY		BIT(25)
+#define AR71XX_I2S_SYNC		BIT(24)
+#define AR71XX_I2S_RXSEX		BIT(23)
+#define AR71XX_I2S_RXF		BIT(22)
+#define AR71XX_I2S_TXE		BIT(21)
+#define AR71XX_I2S_RXD		BIT(20)
+#define AR71XX_I2S_TXD		BIT(19)
+#define AR71XX_I2S_RXR		BIT(18)
+#define AR71XX_I2S_TXW		BIT(17)
+#define AR71XX_I2S_CS_RXERR		BIT(16)
+#define AR71XX_I2S_CS_TXERR		BIT(15)
+#define AR71XX_I2S_RXSYNC		BIT(14)
+#define AR71XX_I2S_TXSYNC		BIT(13)
+#define AR71XX_I2S_DMAEN		BIT(9)
+#define AR71XX_I2S_RXTHR(v)		((v) << 7)
+#define AR71XX_I2S_TXTHR(v)		((v) << 5)
+#define AR71XX_I2S_RXCLR		BIT(4)
+#define AR71XX_I2S_TXCLR		BIT(3)
+#define AR71XX_I2S_TXON		BIT(2)
+#define AR71XX_I2S_RXON		BIT(1)
+#define AR71XX_I2S_EN			(1)
+
+#define AR71XX_I2S_CLKDIS		BIT(28)
+#define AR71XX_I2S_PDMN		BIT(27)
+#define AR71XX_I2S_PDME		BIT(26)
+#define AR71XX_I2S_FRXP		BIT(25)
+#define AR71XX_I2S_FTXP		BIT(24)
+#define AR71XX_I2S_CLKM		BIT(23)
+#define AR71XX_I2S_CLKI		BIT(22)
+#define AR71XX_I2S_FSM		BIT(21)
+#define AR71XX_I2S_FSI		BIT(20)
+#define AR71XX_I2S_FLEN(v)		((v) << 10)
+#define AR71XX_I2S_FSLEN(v)		(v)
+
+#define AR71XX_I2S_CHWEX		BIT(15)
+#define AR71XX_I2S_CHEN		BIT(14)
+#define AR71XX_I2S_CHPOS(v)		((v) << 4)
+#define AR71XX_I2S_CHWID(v)		(v)
+#define AR71XX_I2S_CH1(v)		((v) << 16)
+#define AR71XX_I2S_CH2(v)		(v)
+
+#define AR71XX_I2S_TX_PANIC(v)	((v) << 24)
+#define AR71XX_I2S_RX_PANIC(v)	((v) << 16)
+#define AR71XX_I2S_TX(v)		((v) << 8)
+#define AR71XX_I2S_RX(v)		(v)
+
+#define AR71XX_I2S_INT_RXERR		BIT(3)
+#define AR71XX_I2S_INT_TXERR		BIT(2)
+#define AR71XX_I2S_INT_RXR		BIT(1)
+#define AR71XX_I2S_INT_TXW		BIT(0)
+
+/* I2S DMA interface */
+#define AR71XX_I2S_FIFO_PHYSICAL_ADDR	0x7E203004
+#define AR71XX_DMA_DREQ_PCM_TX		2
+#define AR71XX_DMA_DREQ_PCM_RX		3
+
+#endif
+
+/* I2S DMA interface */
+//MAC Rx High/Low Priority Queue RXDP Pointer
+#define AR71XX_I2S_RX_HP_QUEUE_POINTER	0x18100074
+#define AR71XX_I2S_RX_LP_QUEUE_POINTER	0x18100078
+//QCU Tx Queue Descriptor
+#define AR71XX_I2S_Q_TXDP(v)		(0x18100800 + (v << 2))
+
+#define AR71XX_I2S_FIFO_PHYSICAL_ADDR 	0x00
+
+#define AR71XX_DMA_DREQ_PCM_TX		2
+#define AR71XX_DMA_DREQ_PCM_RX		3
+
+
+#if 0
+/* I2S pin configuration */
+static int ar71xx_i2s_gpio=AR71XX_I2S_GPIO_AUTO;
+#endif
+
+/* General device struct */
+struct ar71xx_i2s_dev {
+	struct device				*dev;
+	struct snd_dmaengine_dai_dma_data	dma_data[2];
+	unsigned int				fmt;
+	unsigned int				bclk_ratio;
+
+	struct regmap *i2s_regmap;
+	struct regmap *gpio_regmap;
+	struct regmap *mbox_regmap;
+};
+
+
+static void ar71xx_i2s_start_clock(struct ar71xx_i2s_dev *dev)
+{
+	printk("called start clock\n");
+
+	/* Start da clock */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+		AR71XX_I2S_ENABLE, AR71XX_I2S_ENABLE);
+}
+
+static void ar71xx_i2s_stop_clock(struct ar71xx_i2s_dev *dev)
+{
+	printk("called stop clock\n");
+
+	/* Stop clock */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_ENABLE, 0x00);
+
+}
+
+static void ar71xx_i2s_clear_fifos(struct ar71xx_i2s_dev *dev,
+				    bool tx, bool rx)
+{
+
+	printk("called clear fifos\n");
+#if 0
+	/* Reset Buffers */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+		AR71XX_I2S_MIC_RESET | AR71XX_I2S_RESET,
+		AR71XX_I2S_MIC_RESET | AR71XX_I2S_RESET);
+	
+
+	int timeout = 1000;
+	uint32_t syncval;
+	uint32_t csreg;
+	uint32_t i2s_active_state;
+	uint32_t clkreg;
+	uint32_t clk_active_state;
+	uint32_t off;
+	uint32_t clr;
+
+	off =  tx ? AR71XX_I2S_TXON : 0;
+	off |= rx ? AR71XX_I2S_RXON : 0;
+
+	clr =  tx ? AR71XX_I2S_TXCLR : 0;
+	clr |= rx ? AR71XX_I2S_RXCLR : 0;
+
+	/* Backup the current state */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &csreg);
+	i2s_active_state = csreg & (AR71XX_I2S_RXON | AR71XX_I2S_TXON);
+
+	regmap_read(dev->clk_regmap, AR71XX_CLK_PCMCTL_REG, &clkreg);
+	clk_active_state = clkreg & AR71XX_CLK_ENAB;
+
+	/* Start clock if not running */
+	if (!clk_active_state) {
+		regmap_update_bits(dev->clk_regmap, AR71XX_CLK_PCMCTL_REG,
+			AR71XX_CLK_PASSWD_MASK | AR71XX_CLK_ENAB,
+			AR71XX_CLK_PASSWD | AR71XX_CLK_ENAB);
+	}
+
+	/* Stop I2S module */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, off, 0);
+
+	/*
+	 * Clear the FIFOs
+	 * Requires at least 2 PCM clock cycles to take effect
+	 */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, clr, clr);
+
+	/* Wait for 2 PCM clock cycles */
+
+	/*
+	 * Toggle the SYNC flag. After 2 PCM clock cycles it can be read back
+	 * FIXME: This does not seem to work for slave mode!
+	 */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &syncval);
+	syncval &= AR71XX_I2S_SYNC;
+
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_SYNC, ~syncval);
+
+	/* Wait for the SYNC flag changing it's state */
+	while (--timeout) {
+		regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &csreg);
+		if ((csreg & AR71XX_I2S_SYNC) != syncval)
+			break;
+	}
+
+	if (!timeout)
+		dev_err(dev->dev, "I2S SYNC error!\n");
+
+	/* Stop clock if it was not running before */
+	if (!clk_active_state)
+		ar71xx_i2s_stop_clock(dev);
+
+	/* Restore I2S state */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_RXON | AR71XX_I2S_TXON, i2s_active_state);
+#endif
+}
+
+static int ar71xx_i2s_set_dai_fmt(struct snd_soc_dai *dai,
+				      unsigned int fmt)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	dev->fmt = fmt;
+	return 0;
+}
+
+
+//TODO
+static int ar71xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	unsigned int sampling_rate = params_rate(params);
+	unsigned int divi, divf, mclk_frequency, posedge;
+	unsigned int conf, i2s_word_size;
+	unsigned int master = dev->fmt & SND_SOC_DAIFMT_MASTER_MASK;
+	int clk_src = AR71XX_CLK_SRC_CPU;
+	int channels;
+#if 0
+	bool bit_master =	(master == SND_SOC_DAIFMT_CBS_CFS
+					|| master == SND_SOC_DAIFMT_CBS_CFM);
+
+	bool frame_master =	(master == SND_SOC_DAIFMT_CBS_CFS
+					|| master == SND_SOC_DAIFMT_CBM_CFS);
+#endif
+
+
+	unsigned int mclk_ratio = 256;  /* see supported ratios of TAS5711 */
+	uint64_t dividend;
+	uint32_t confreg;
+
+	printk("called hw params\n");
+
+	/*
+	 * If a stream is already enabled,
+	 * the registers are already set properly.
+	 */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, &confreg);
+	
+	// I2S enabled
+	if (confreg & AR71XX_I2S_ENABLE)
+		return 0;
+
+
+	/* Route the i2s pins to the gpios */
+	regmap_update_bits(dev->gpio_regmap, 
+		AR71XX_GPIO_FUNCTION,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN);
+	
+
+	/* Set configurations 
+	 *
+	 * DIV_BYPASS = 0 	--> Divider not bypassed
+	 * AUDIO_CLOCK_SEL = 0	--> use CPU clock
+	 * SPDIF_ENABLE = 0	--> SPDIF is disabled
+	 * SAMPLE_CNT_CLEAR_TYPE = 0 --> explicit zero is written to sample counters
+	 */
+	conf = 0;
+
+	// TODO check is clock is maybe inverted by default
+	/* Clock inversion is not supported */
+	if ((dev->fmt & SND_SOC_DAIFMT_INV_MASK) == SND_SOC_DAIFMT_NB_NF) {
+		dev_err(dev->dev, "Clock inversion not supported\n");
+		return -EINVAL;
+	}
+
+	
+	/* Set master/slave */
+	switch (dev->fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* CPU is master */
+		conf |= AR71XX_I2S_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* CODEC is master */
+		//TODO has to be tested!
+		conf |= AR71XX_I2S_REFCLK_SEL;
+		conf |= AR71XX_I2S_MCK_SEL;
+		break;
+	default:
+		dev_err(dev->dev, "%s:bad master\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set format */
+	switch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		conf |= AR71XX_I2S_I2S_DELAY;
+		break;
+	default:
+		/*
+		 * TODO
+		 * Others are possible but are not implemented at the moment.
+		 * Only unset delay bit??
+		 */
+		dev_err(dev->dev, "%s:bad format\n", __func__);
+		return -EINVAL;
+	}
+
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		i2s_word_size = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_word_size = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		i2s_word_size = 32;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set PCM swap */
+	//TODO
+	// set bit according to SNDRV_PCM_FORMAT (BE or LE)
+
+	/* Set input (mic) word size */
+	//TODO
+	// 1 = 32 Bit
+	conf |= AR71XX_I2S_MIC_WORD_SIZE;
+
+	/* Set Stereo/Mono */
+	switch (params_channels(params)) {
+	case 2:
+		//TODO mono supported? set STEREO_MONO
+		/* Stereo is default so STEREO_MONO needn't be set */
+		channels = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set internal data word size */
+	//TODO
+	conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_32);
+
+	/* Set output (I2S DAC) word size */
+	//TODO
+	// 1 = 32 Bit
+	conf |= AR71XX_I2S_I2S_WORD_SIZE;
+
+	/* Write configurations to register */
+	regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, conf);
+
+
+	mclk_frequency = sampling_rate * mclk_ratio * 2; // TODO find out where the 2 comes from. what a mistery! 
+
+	dividend = ar71xx_clk_freq[clk_src];
+	dividend <<= AR71XX_I2S_CLK_SHIFT;
+	do_div(dividend, mclk_frequency);
+	divi = dividend >> AR71XX_I2S_CLK_SHIFT;
+	divf = dividend & AR71XX_I2S_CLK_DIVF_MASK;
+
+	posedge = mclk_ratio / (channels * 64);
+
+
+	/* Set clock divider */
+	regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CLK_DIV,
+			AR71XX_I2S_DIV_INT(divi) | AR71XX_I2S_DIV_FRAC(divf));
+
+	/* Set posedge */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_POSEDGE_MASK, AR71XX_I2S_POSEDGE(posedge));
+
+	//TODO these registers might be in the MBOX
+	//leave it empty for now as we only care about the clock
+#if 0
+	/* Setup the DMA parameters */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_RXTHR(1)
+			| AR71XX_I2S_TXTHR(1)
+			| AR71XX_I2S_DMAEN, 0xffffffff);
+
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_DREQ_A_REG,
+			  AR71XX_I2S_TX_PANIC(0x10)
+			| AR71XX_I2S_RX_PANIC(0x30)
+			| AR71XX_I2S_TX(0x30)
+			| AR71XX_I2S_RX(0x20), 0xffffffff);
+
+	/* Clear FIFOs */
+	ar71xx_i2s_clear_fifos(dev, true, true);
+#endif
+	return 0;
+
+}
+
+static int ar71xx_i2s_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	//uint32_t conf_reg;
+
+	printk("called prepare\n");
+	
+
+	ar71xx_i2s_start_clock(dev);
+
+#if 0
+	/*
+	 * Clear both FIFOs if the one that should be started
+	 * is not empty at the moment. This should only happen
+	 * after overrun. Otherwise, hw_params would have cleared
+	 * the FIFO.
+	 */
+	regmap_read(dev->i2s_regmap, AR71XX_I2S_CS_A_REG, &cs_reg);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK
+			&& !(cs_reg & AR71XX_I2S_TXE))
+		ar71xx_i2s_clear_fifos(dev, true, false);
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE
+			&& (cs_reg & AR71XX_I2S_RXD))
+		ar71xx_i2s_clear_fifos(dev, false, true);
+
+#endif
+	return 0;
+}
+
+static void ar71xx_i2s_stop(struct ar71xx_i2s_dev *dev,
+		struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	//uint32_t mask;
+
+	printk("called stop\n");
+
+#if 0
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		mask = AR71XX_I2S_RXON;
+	else
+		mask = AR71XX_I2S_TXON;
+
+	regmap_update_bits(dev->i2s_regmap,
+			AR71XX_I2S_CS_A_REG, mask, 0);
+#endif
+
+	/* Stop also the clock when not SND_SOC_DAIFMT_CONT */
+	if (!dai->active && !(dev->fmt & SND_SOC_DAIFMT_CONT))
+		ar71xx_i2s_stop_clock(dev);
+}
+
+static int ar71xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	//uint32_t mask;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		ar71xx_i2s_start_clock(dev);
+#if 0
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			mask = AR71XX_I2S_RXON;
+		else
+			mask = AR71XX_I2S_TXON;
+
+		regmap_update_bits(dev->i2s_regmap,
+				AR71XX_I2S_CS_A_REG, mask, mask);
+#endif
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		ar71xx_i2s_stop(dev, substream, dai);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int ar71xx_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	
+	printk("called startup\n");
+
+	if (dai->active)
+		return 0;
+
+	/* Should this still be running stop it */
+	ar71xx_i2s_stop_clock(dev);
+
+	//TODO I2S block can't be enabled i think...
+#if 0
+	/* Enable PCM block */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_ENABLE, AR71XX_I2S_ENABLE);
+#endif
+
+//no standby regs available
+#if 0
+	/*
+	 * Disable STBY.
+	 * Requires at least 4 PCM clock cycles to take effect.
+	 */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_CS_A_REG,
+			AR71XX_I2S_STBY, AR71XX_I2S_STBY);
+#endif
+
+	return 0;
+}
+
+static void ar71xx_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	
+	printk("called shutdown\n");
+
+	ar71xx_i2s_stop(dev, substream, dai);
+
+	/* If both streams are stopped, disable module and clock */
+	if (dai->active)
+		return;
+
+	//TODO see startup
+#if 0
+	/* Disable the module */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_ENABLE, 0);
+#endif
+
+	/*
+	 * Stopping clock is necessary, because stop does
+	 * not stop the clock when SND_SOC_DAIFMT_CONT
+	 */
+	ar71xx_i2s_stop_clock(dev);
+}
+
+
+static const struct snd_soc_dai_ops ar71xx_i2s_dai_ops = {
+
+	.startup	= ar71xx_i2s_startup,
+	.shutdown	= ar71xx_i2s_shutdown,
+	.prepare	= ar71xx_i2s_prepare,
+	.trigger	= ar71xx_i2s_trigger,
+	.hw_params	= ar71xx_i2s_hw_params,
+	.set_fmt	= ar71xx_i2s_set_dai_fmt,
+
+};
+
+static int ar71xx_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK];
+	dai->capture_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE];
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver ar71xx_i2s_dai = {
+	//TODO check available formats on ar9331
+	.name	= "ar71xx-i2s",
+	.probe	= ar71xx_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_8000_192000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_8000_192000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.ops = &ar71xx_i2s_dai_ops,
+	.symmetric_rates = 1
+};
+
+#if 0
+
+static bool ar71xx_i2s_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_CS_A_REG:
+	case AR71XX_I2S_FIFO_A_REG:
+	case AR71XX_I2S_INTSTC_A_REG:
+	case AR71XX_I2S_GRAY_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_i2s_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_FIFO_A_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_clk_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_CLK_PCMCTL_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+#endif
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	/* I2S Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_I2S_STEREO0_CLK_DIV,
+		//.precious_reg = ar71xx_i2s_precious_reg,
+		//.volatile_reg = ar71xx_i2s_volatile_reg,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* MBOX DMA Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_SLIC_MBOX_FIFO_RESET,
+		//.volatile_reg = ar71xx_clk_volatile_reg,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* GPIO Registers (only GPIO Function) */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_GPIO_FUNCTION,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+
+
+static const struct snd_soc_component_driver ar71xx_i2s_component = {
+	.name		= "ar71xx-i2s-comp",
+};
+
+static const struct snd_pcm_hardware ar71xx_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_JOINT_DUPLEX,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S24_LE |
+				  SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 64 * PAGE_SIZE,
+	.periods_min		= 2,
+	.periods_max		= 255,
+	.buffer_bytes_max	= 128 * PAGE_SIZE,
+};
+
+static const struct snd_dmaengine_pcm_config ar71xx_dmaengine_pcm_config = {
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.pcm_hardware = &ar71xx_pcm_hardware,
+	.prealloc_buffer_size = 256 * PAGE_SIZE,
+};
+
+
+static int ar71xx_i2s_probe(struct platform_device *pdev)
+{
+	struct ar71xx_i2s_dev *dev;
+	int i;
+	int ret;
+	struct regmap *regmap[3];
+	struct resource *mem[3];
+
+
+	printk("started probe\n");
+	
+
+	/* Request ioareas */
+	for (i = 0; i < 3; i++) {
+		void __iomem *base;
+
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base,
+					    &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "I2S probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	}
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev),
+			   GFP_KERNEL);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	dev->i2s_regmap = regmap[0];
+	dev->mbox_regmap = regmap[1];
+	dev->gpio_regmap = regmap[2];
+
+
+	/* Set the DMA address */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr =
+		(dma_addr_t)AR71XX_I2S_FIFO_PHYSICAL_ADDR;
+
+	/* Set the DREQ */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].slave_id =
+		AR71XX_DMA_DREQ_PCM_TX;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].slave_id =
+		AR71XX_DMA_DREQ_PCM_RX;
+
+	/* Set the bus width */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width =
+		DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	/* Set burst */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 2;
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 2;
+	
+	//XXX
+	/* Set name */
+	dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].chan_name = "playback_channel";
+	dev->dma_data[SNDRV_PCM_STREAM_CAPTURE].chan_name = "capture_channel";
+
+	/* BCLK ratio - use default */
+	dev->bclk_ratio = 0;
+
+	/* Store the pdev */
+	dev->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, dev);
+
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&ar71xx_i2s_component, &ar71xx_i2s_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = snd_dmaengine_pcm_register(&pdev->dev,
+				&ar71xx_dmaengine_pcm_config,
+				SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		snd_soc_unregister_component(&pdev->dev);
+		return ret;
+	}
+
+
+	return 0;
+}
+
+static int ar71xx_i2s_remove(struct platform_device *pdev)
+{
+	printk("called remove\n");
+
+	snd_dmaengine_pcm_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_i2s_driver = {
+	.probe		= ar71xx_i2s_probe,
+	.remove		= ar71xx_i2s_remove,
+	.driver		= {
+		.name	= "ar71xx-i2s",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_i2s_driver);
+
+MODULE_ALIAS("platform:ar71xx-i2s");
+MODULE_DESCRIPTION("AR71XX I2S interface");
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_GENERIC_DMAENGINE_PCM
 	select SND_SOC_DMAENGINE_PCM
 
 # All the supported SoCs
+source "sound/soc/ar71xx/Kconfig"
 source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/blackfin/Kconfig"
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -12,6 +12,7 @@ endif
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/
 obj-$(CONFIG_SND_SOC)	+= generic/
+obj-$(CONFIG_SND_SOC)	+= ar71xx/
 obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= blackfin/
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -105,6 +105,8 @@ int snd_soc_dai_set_clkdiv(struct snd_so
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, int source, unsigned int freq_in, unsigned int freq_out);
 
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int radio);
+
 /* Digital Audio interface formatting */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt);
 
@@ -131,6 +133,7 @@ struct snd_soc_dai_ops {
 	int (*set_pll)(struct snd_soc_dai *dai, int pll_id, int source,
 		unsigned int freq_in, unsigned int freq_out);
 	int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
+	int (*set_bclk_ratio)(struct snd_soc_dai *dai, unsigned int radio);
 
 	/*
 	 * DAI format configuration
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.h
@@ -0,0 +1,26 @@
+/*
+ * I2S configuration for sound cards. 
+ *
+ * Copyright (c) 2014 Daniel Matuschek <daniel@hifiberry.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AR71XX_I2S_H
+#define AR71XX_I2S_H
+
+
+
+#endif
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3398,6 +3398,22 @@ int snd_soc_codec_set_sysclk(struct snd_
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 
 /**
+ * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio: Rtio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio
+ */
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	if (dai->driver && dai->driver->ops->set_bclk_ratio)
+		return dai->driver->ops->set_bclk_ratio(dai, ratio);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
+
+/**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
  * @div_id: DAI specific clock divider ID
--- /dev/null
+++ b/arch/mips/ath79/dev-i2s.c
@@ -0,0 +1,23 @@
+/*
+ *  Atheros AR9331 I2S Audio support
+ *
+ *  Copyright (C) 2014 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-i2s.h"
+
+int __init ath79_register_i2s(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		pr_debug("Unable to register platform devices '%s' %d\n",
+		         pdev->name, ret);
+
+	return ret;
+}
--- /dev/null
+++ b/arch/mips/ath79/dev-i2s.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR9331 I2S Audio support
+ *
+ *  Copyright (C) 2014 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_I2S_H
+#define _ATH79_DEV_I2S_H
+
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+
+int __init ath79_register_i2s(struct platform_device *pdev);
+
+
+#endif /* _ATH79_DEV_I2S_H */
--- a/arch/mips/ath79/mach-carambola2.c
+++ b/arch/mips/ath79/mach-carambola2.c
@@ -18,6 +18,7 @@
 #include "dev-spi.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
+#include "dev-i2s.h"
 #include "machtypes.h"
 
 #define CARAMBOLA2_GPIO_LED_WLAN		0
@@ -61,6 +62,49 @@ static struct gpio_keys_button carambola
 	},
 };
 
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+static struct resource ar9331_i2s_resources[] = {
+	{
+		.start	= AR933X_I2S_BASE,
+		.end	= AR933X_I2S_BASE + AR933X_I2S_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "i2s-registers"
+	},
+	{
+		.start	= AR933X_MBOX_BASE,
+		.end	= AR933X_MBOX_BASE + AR933X_MBOX_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "mbox-registers"
+	},
+	{
+		.start	= AR71XX_GPIO_BASE,
+		.end	= AR71XX_GPIO_BASE + AR71XX_GPIO_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "gpio-registers"
+	}
+};
+
+static struct platform_device ar9331_i2s_device = {
+	.name		= "ar71xx-i2s",
+	.resource	= ar9331_i2s_resources,
+	.num_resources	= ARRAY_SIZE(ar9331_i2s_resources),
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+static struct platform_device snd_hifiberry_dac_device = {
+	.name 		= "snd-hifiberry-dac",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static struct platform_device snd_pcm5102a_codec_device = {
+	.name		= "pcm5102a-codec",
+	.id		= -1,
+	.num_resources	= 0,
+};
+#endif
+
 static void __init carambola2_common_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
@@ -81,6 +125,17 @@ static void __init carambola2_common_set
 
 	/* WAN port */
 	ath79_register_eth(0);
+
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+	/* I2S module */
+	ath79_register_i2s(&ar9331_i2s_device);
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+	/* Hifiberry dac module */
+	ath79_register_i2s(&snd_hifiberry_dac_device);
+	ath79_register_i2s(&snd_pcm5102a_codec_device);
+#endif
 }
 
 static void __init carambola2_setup(void)
--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
@@ -94,6 +94,10 @@
 #define AR933X_WMAC_SIZE	0x20000
 #define AR933X_EHCI_BASE	0x1b000000
 #define AR933X_EHCI_SIZE	0x1000
+#define AR933X_I2S_BASE		(AR71XX_APB_BASE + 0x000B0000)
+#define AR933X_I2S_SIZE		0x20
+#define AR933X_MBOX_BASE	(AR71XX_APB_BASE + 0x000A0000)
+#define AR933X_MBOX_SIZE	0x58
 
 #define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
 #define AR934X_GMAC_SIZE	0x14
--- a/arch/mips/ath79/Kconfig
+++ b/arch/mips/ath79/Kconfig
@@ -1014,6 +1014,7 @@ config ATH79_MACH_CARAMBOLA2
 	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
+	select ATH79_DEV_I2S
 
 config ATH79_MACH_BHU_BXU2000N2_A
 	bool "BHU BXU2000n-2 rev. A support"
@@ -1100,6 +1101,9 @@ config ATH79_DEV_SPI
 config ATH79_DEV_USB
 	def_bool n
 
+config ATH79_DEV_I2S
+	def_bool n
+
 config ATH79_DEV_WMAC
 	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
 	def_bool n
--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_ATH79_DEV_NFC)		+= dev-nfc.
 obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
 obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
 obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+obj-$(CONFIG_ATH79_DEV_I2S)		+= dev-i2s.o
 
 #
 # Miscellaneous objects
--- /dev/null
+++ b/sound/soc/ar71xx/hifiberry_dac.c
@@ -0,0 +1,112 @@
+/*
+ * ASoC Driver for HifiBerry DAC
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * TODO:
+ * - CPU DAI Name
+ * - Platform Name
+ *
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+
+static int snd_rpi_hifiberry_dac_init(struct snd_soc_pcm_runtime *rtd)
+{
+	printk("in dac_init\n");
+	return 0;
+}
+
+static int snd_rpi_hifiberry_dac_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	printk("in dac_hw_params\n");
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	unsigned int sample_bits =
+		snd_pcm_format_physical_width(params_format(params));
+
+	return snd_soc_dai_set_bclk_ratio(cpu_dai, sample_bits * 2);
+}
+
+/* machine stream operations */
+static struct snd_soc_ops snd_rpi_hifiberry_dac_ops = {
+	.hw_params = snd_rpi_hifiberry_dac_hw_params,
+};
+
+static struct snd_soc_dai_link snd_rpi_hifiberry_dac_dai[] = {
+{
+	.name		= "HifiBerry DAC",
+	.stream_name	= "HifiBerry DAC HiFi",
+	.cpu_dai_name	= "ar71xx-i2s.0",
+	.codec_dai_name	= "pcm5102a-hifi",
+	.platform_name	= "ar71xx-i2s.0",
+	.codec_name	= "pcm5102a-codec",
+	.dai_fmt	= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				SND_SOC_DAIFMT_CBS_CFS,
+	.ops		= &snd_rpi_hifiberry_dac_ops,
+	.init		= snd_rpi_hifiberry_dac_init,
+},
+};
+
+/* audio machine driver */
+static struct snd_soc_card snd_rpi_hifiberry_dac = {
+	.name         = "snd_carambola2_hifiberry_dac",
+	.dai_link     = snd_rpi_hifiberry_dac_dai,
+	.num_links    = ARRAY_SIZE(snd_rpi_hifiberry_dac_dai),
+};
+
+static int snd_rpi_hifiberry_dac_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	dev_info(&pdev->dev, "in ..._dac_probe()\n");
+
+	snd_rpi_hifiberry_dac.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_rpi_hifiberry_dac);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+
+	return ret;
+}
+
+static int snd_rpi_hifiberry_dac_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "in ..._dac_remove()\n");
+
+	return snd_soc_unregister_card(&snd_rpi_hifiberry_dac);
+}
+
+static struct platform_driver snd_rpi_hifiberry_dac_driver = {
+        .driver = {
+                .name   = "snd-hifiberry-dac",
+                .owner  = THIS_MODULE,
+        },
+        .probe          = snd_rpi_hifiberry_dac_probe,
+        .remove         = snd_rpi_hifiberry_dac_remove,
+};
+
+module_platform_driver(snd_rpi_hifiberry_dac_driver);
+
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_DESCRIPTION("ASoC Driver for HifiBerry DAC");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -55,6 +55,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ML26124 if I2C
 	select SND_SOC_OMAP_HDMI_CODEC if OMAP4_DSS_HDMI
 	select SND_SOC_PCM3008
+	select SND_SOC_PCM5102A
 	select SND_SOC_RT5631 if I2C
 	select SND_SOC_SGTL5000 if I2C
 	select SND_SOC_SI476X if MFD_SI476X_CORE
@@ -293,6 +294,9 @@ config SND_SOC_OMAP_HDMI_CODEC
 config SND_SOC_PCM3008
        tristate
 
+config SND_SOC_PCM5102A
+       tristate
+
 config SND_SOC_RT5631
 	tristate
 
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -43,6 +43,7 @@ snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-omap-hdmi-codec-objs := omap-hdmi.o
 snd-soc-pcm3008-objs := pcm3008.o
+snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-rt5631-objs := rt5631.o
 snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-alc5623-objs := alc5623.o
@@ -170,6 +171,7 @@ obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_OMAP_HDMI_CODEC) += snd-soc-omap-hdmi-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
+obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
 obj-$(CONFIG_SND_SOC_SGTL5000)  += snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_SIGMADSP)	+= snd-soc-sigmadsp.o
--- /dev/null
+++ b/sound/soc/codecs/pcm5102a.c
@@ -0,0 +1,73 @@
+/*
+ * Driver for the PCM5102A codec
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static struct snd_soc_dai_driver pcm5102a_dai = {
+	.name = "pcm5102a-hifi",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   // SNDRV_PCM_FMTBIT_S24_LE | : disable for now, it causes white noise with xbmc
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE | 
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_pcm5102a;
+
+static int pcm5102a_probe(struct platform_device *pdev)
+{
+	printk("in pcm5102a_probe()\ndoing snd_soc_register_codec() now\n");
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pcm5102a,
+			&pcm5102a_dai, 1);
+}
+
+static int pcm5102a_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver pcm5102a_codec_driver = {
+	.probe 		= pcm5102a_probe,
+	.remove 	= pcm5102a_remove,
+	.driver		= {
+		.name	= "pcm5102a-codec",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(pcm5102a_codec_driver);
+
+MODULE_DESCRIPTION("ASoC PCM5102A codec driver");
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_LICENSE("GPL v2");
