--- /dev/null
+++ b/sound/soc/ar71xx/Kconfig
@@ -0,0 +1,27 @@
+config SND_SOC_AR71XX_PCM
+	tristate "AR9331 PCM Audio Driver"
+	select REGMAP_MMIO
+	select SND_SOC_DMAENGINE_PCM
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_AR71XX_I2S
+	help
+	  Say Y or M...
+
+config SND_SOC_AR71XX_I2S
+	tristate
+
+config SND_SOC_AR71XX_HIFIBERRY_DAC
+	tristate "Hifiberry DAC Machine Driver"
+	depends on SND_SOC_AR71XX_PCM
+	depends on SND_SOC_AR71XX_I2S
+	select SND_SOC_PCM5102A
+	help
+	  Say Y or M...
+
+config SND_SOC_AR71XX_TAS5711_EVB
+	tristate "TAS5711 Evaluation Board Machine Driver"
+	depends on SND_SOC_AR71XX_PCM
+	depends on SND_SOC_AR71XX_I2S
+	select SND_SOC_TAS5711
+	help
+	  Say Y or M...
--- /dev/null
+++ b/sound/soc/ar71xx/Makefile
@@ -0,0 +1,15 @@
+# AR71XX Platform Support
+snd-soc-ar71xx-i2s-objs := ar71xx-i2s.o
+snd-soc-ar71xx-pcm-objs := ar71xx-pcm.o ar71xx-mbox.o
+#snd-soc-ar71xx-mbox-objs := ar71xx-mbox.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_I2S) += snd-soc-ar71xx-i2s.o
+obj-$(CONFIG_SND_SOC_AR71XX_PCM) += snd-soc-ar71xx-pcm.o
+#obj-$(CONFIG_SND_SOC_AR71XX_MBOX) += snd-soc-ar71xx-mbox.o
+
+# AR71XX Machine Support
+snd-soc-ar71xx-hifiberry-dac-objs := hifiberry_dac.o
+snd-soc-ar71xx-tas5711-ev-board-objs := tas5711_ev-board.o
+
+obj-$(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) += snd-soc-ar71xx-hifiberry-dac.o
+obj-$(CONFIG_SND_SOC_AR71XX_TAS5711_EVB) += snd-soc-ar71xx-tas5711-ev-board.o
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.c
@@ -0,0 +1,533 @@
+/*
+ * a71xx-i2s.c -- ALSA I2S interface
+ *
+ * ALSA SoC PCM Audio Layer for Atheros AR9331 SoC
+ *
+ * Copyright (c) 2014-2015 Felix Kramer <felixkramerroki@aol.com> All rights reserved
+ *
+ * <felixkramerroki@aol.com>
+ *
+ * Based on
+ *	ath79 QCA Audio Driver
+ *	Copyright (c) by Qualcom Atheros, Inc. 2013
+ *
+ *	Raspberry Pi I2S ALSA Driver
+ *	Copyright (c) by Florian Meier 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+//TODO setup gpio pins somewhere
+
+#include "ar71xx-i2s.h"
+
+
+enum {
+	AR71XX_CLK_SRC_CPU = 0,
+	AR71XX_CLK_SRC_OSC,
+};
+
+
+static const unsigned int ar71xx_clk_freq[AR71XX_CLK_SRC_OSC+1] = {
+	[AR71XX_CLK_SRC_CPU]		= 400000000,
+	[AR71XX_CLK_SRC_OSC]		= 176000000,
+};
+
+/* GPIOs for Regmap testing */
+#define AR71XX_GPIO_OE			0x00
+#define AR71XX_GPIO_SET			0x0c
+#define AR71XX_GPIO_CLEAR		0x10
+
+#define AR71XX_GPIO_PIN(v)		(1 << (v))
+
+
+/* GPIO function registers */
+#define AR71XX_GPIO_FUNCTION			0x28
+#define AR71XX_GPIO_FUNCTION_SPDIF2TCK		BIT(31)
+#define AR71XX_GPIO_FUNCTION_SPDIF_EN		BIT(30)
+#define AR71XX_GPIO_FUNCTION_I2SO_22_18_EN	BIT(29)
+#define AR71XX_GPIO_FUNCTION_I2S_MCKEN		BIT(27)
+#define AR71XX_GPIO_FUNCTION_I2SO_EN		BIT(26)
+
+/* I2S registers */
+#define AR71XX_I2S_STEREO0_CONFIG		0x00
+#define AR71XX_I2S_STEREO0_VOLUME		0x04
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_LSB	0x0C
+#define AR71XX_I2S_STEREO0_TX_SAMPLE_CNT_MSB	0x10
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_LSB	0x14
+#define AR71XX_I2S_STEREO0_RX_SAMPLE_CNT_MSB	0x18
+#define AR71XX_I2S_STEREO0_CLK_DIV		0x1C
+
+/* STEREO0_CONFIG masks */
+#define AR71XX_I2S_DIV_BYPASS			BIT(25)
+#define AR71XX_I2S_AUDIO_CLOCK_SEL		BIT(24)
+#define AR71XX_I2S_SPDIF_ENABLE			BIT(23)
+#define AR71XX_I2S_REFCLK_SEL			BIT(22)
+#define AR71XX_I2S_ENABLE			BIT(21)
+#define AR71XX_I2S_MIC_RESET			BIT(20)
+#define AR71XX_I2S_RESET			BIT(19)
+#define AR71XX_I2S_I2S_DELAY			BIT(18)
+#define AR71XX_I2S_PCM_SWAP			BIT(17)
+#define AR71XX_I2S_MIC_WORD_SIZE		BIT(16)
+#define AR71XX_I2S_SETERO_MONO(v)		(((v) & 0x3) << 14)
+enum {
+	AR71XX_I2S_STEREO = 0,
+	AR71XX_I2S_MONO_CHNL0,
+	AR71XX_I2S_MONO_CHNL1,
+};
+
+#define AR71XX_I2S_DATA_WORD_SIZE(v)		(((v) & 0x3) << 12)
+enum {
+	AR71XX_I2S_DATA_WORD_8 = 0,
+	AR71XX_I2S_DATA_WORD_16,
+	AR71XX_I2S_DATA_WORD_24,
+	AR71XX_I2S_DATA_WORD_32,
+};
+
+#define AR71XX_I2S_I2S_WORD_SIZE		BIT(11)
+#define AR71XX_I2S_MCK_SEL			BIT(10)
+#define AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE	BIT(9)
+#define AR71XX_I2S_MASTER			BIT(8)
+#define AR71XX_I2S_POSEDGE(v)			((v) & 0x7f)
+#define AR71XX_I2S_POSEDGE_MASK			0x7f
+
+/* STEREO0_VOLUME masks */
+#define AR71XX_I2S_CHANNEL1(v)			((v) << 8)
+#define AR71XX_I2S_CHANNEL0(v)			(v)
+
+/* Tx and Rx Counter masks */
+#define AR71XX_I2S_SAMPLE_COUNTER_CH0		(0xFFFF)
+#define AR71XX_I2S_SAMPLE_COUNTER_CH1		(0xFFFF << 16)
+
+/* STEREO_CLOCK_DIV masks */
+#define AR71XX_I2S_CLK_SHIFT			16
+#define AR71XX_I2S_CLK_DIVF_MASK		0xffff
+#define AR71XX_I2S_DIV_INT(v)			((v) << AR71XX_I2S_CLK_SHIFT)
+#define AR71XX_I2S_DIV_FRAC(v)			(v)
+
+
+/* General device struct */
+struct ar71xx_i2s_dev {
+	struct device		*dev;
+	struct regmap 		*i2s_regmap;
+	struct regmap 		*gpio_regmap;
+	unsigned int		fmt;
+};
+
+void ar71xx_stereo_reset(struct ar71xx_i2s_dev *dev)
+{
+	/* set reset bit in STEREO0_CONFIG */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_RESET, AR71XX_I2S_RESET);
+}
+
+static int ar71xx_i2s_set_dai_fmt(struct snd_soc_dai *dai,
+				      unsigned int fmt)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	dev->fmt = fmt;
+	return 0;
+}
+
+
+static int ar71xx_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	unsigned int sampling_rate = params_rate(params);
+	unsigned int divi, divf, mclk_frequency, posedge;
+	unsigned int i2s_word_size;
+	uint32_t conf;
+	int clk_src = AR71XX_CLK_SRC_CPU;
+	int channels;
+	unsigned int mclk_ratio = 256;  /* see supported ratios of TAS5711 */
+	uint64_t dividend;
+
+	/* --- Configurations --- */
+
+	/* DIV_BYPASS = 0 	--> Divider not bypassed
+	 * AUDIO_CLOCK_SEL = 0	--> use CPU clock
+	 * SPDIF_ENABLE = 0	--> SPDIF is disabled
+	 * SAMPLE_CNT_CLEAR_TYPE = 0 --> explicit zero is written to sample counters */
+	conf = 0;
+
+	// TODO this becomes false and returns here
+#if 0
+	/* Clock inversion is not supported */
+	if ((dev->fmt & SND_SOC_DAIFMT_INV_MASK) == SND_SOC_DAIFMT_NB_NF) {
+		dev_err(dev->dev, "Clock inversion not supported\n");
+		return -EINVAL;
+	}
+#endif
+
+
+	/* Set master/slave */
+	switch (dev->fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* CPU is master */
+		conf |= AR71XX_I2S_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		/* CODEC is master */
+		//TODO has to be tested!
+		conf |= AR71XX_I2S_REFCLK_SEL;
+		conf |= AR71XX_I2S_MCK_SEL;
+		break;
+	default:
+		dev_err(dev->dev, "%s:bad master\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set format */
+	switch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		conf |= AR71XX_I2S_I2S_DELAY;
+		break;
+	default:
+		/*
+		 * TODO
+		 * Others are possible but are not implemented at the moment.
+		 * Only unset delay bit??
+		 */
+		dev_err(dev->dev, "%s:bad format\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Set output (I2S DAC) word size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_8);
+		i2s_word_size = 8;
+		break;
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S16_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_16);
+		i2s_word_size = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S24_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_24);
+		conf |= AR71XX_I2S_I2S_WORD_SIZE;
+		conf |= AR71XX_I2S_MIC_WORD_SIZE; /* check if good here */
+		i2s_word_size = 24;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		conf |= AR71XX_I2S_PCM_SWAP;
+	case SNDRV_PCM_FORMAT_S32_BE:
+		conf |= AR71XX_I2S_DATA_WORD_SIZE(AR71XX_I2S_DATA_WORD_32);
+		conf |= AR71XX_I2S_I2S_WORD_SIZE;
+		conf |= AR71XX_I2S_MIC_WORD_SIZE;
+		i2s_word_size = 32;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* Set Stereo/Mono */
+	switch (params_channels(params)) {
+	case 2:
+		//TODO mono supported? set STEREO_MONO
+		/* Stereo is default so STEREO_MONO needn't be set */
+		channels = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* Write configurations to register */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, conf, conf);
+
+
+	/* --- clock divider --- */
+	mclk_frequency = sampling_rate * mclk_ratio * 2; // TODO find out where the 2 comes from. what a mistery!
+
+	dividend = ar71xx_clk_freq[clk_src];
+	dividend <<= AR71XX_I2S_CLK_SHIFT;
+	do_div(dividend, mclk_frequency);
+	divi = dividend >> AR71XX_I2S_CLK_SHIFT;
+	divf = dividend & AR71XX_I2S_CLK_DIVF_MASK;
+
+	posedge = mclk_ratio / (channels * 64);
+
+	/* write clock divider to register */
+	regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CLK_DIV,
+			AR71XX_I2S_DIV_INT(divi) | AR71XX_I2S_DIV_FRAC(divf));
+
+	//TODO do only one write to STEREO0_CONFIG
+	/* Set posedge */
+	regmap_update_bits(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			AR71XX_I2S_POSEDGE_MASK, AR71XX_I2S_POSEDGE(posedge));
+
+
+	ar71xx_stereo_reset(dev);
+
+	return 0;
+}
+
+static int ar71xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+
+static int ar71xx_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	/* Route the i2s pins to the gpios */
+	regmap_update_bits(dev->gpio_regmap,
+		AR71XX_GPIO_FUNCTION,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN,
+		AR71XX_GPIO_FUNCTION_I2SO_22_18_EN |
+			AR71XX_GPIO_FUNCTION_I2S_MCKEN |
+			AR71XX_GPIO_FUNCTION_I2SO_EN);
+
+
+	if (!dai->active) {
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG,
+			  AR71XX_I2S_SPDIF_ENABLE
+			| AR71XX_I2S_ENABLE
+			| AR71XX_I2S_SAMPLE_CNT_CLEAR_TYPE
+			| AR71XX_I2S_MASTER);
+
+		ar71xx_stereo_reset(dev);
+	}
+
+	return 0;
+}
+
+static void ar71xx_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	/* If both streams are stopped, disable module and clock */
+	if (dai->active) {
+		printk("setting STEREO0_CONFIG to 0x00\n");
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 0x00);
+		ar71xx_stereo_reset(dev);
+	} else {
+		//XXX force stopping for now
+		regmap_write(dev->i2s_regmap, AR71XX_I2S_STEREO0_CONFIG, 0x00);
+		ar71xx_stereo_reset(dev);
+	}
+}
+
+
+static const struct snd_soc_dai_ops ar71xx_i2s_dai_ops = {
+
+	.startup	= ar71xx_i2s_startup,
+	.shutdown	= ar71xx_i2s_shutdown,
+	.trigger	= ar71xx_i2s_trigger,
+	.hw_params	= ar71xx_i2s_hw_params,
+	.set_fmt 	= ar71xx_i2s_set_dai_fmt,
+
+};
+
+#if 0
+static int ar71xx_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct ar71xx_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	dai->playback_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK];
+	dai->capture_dma_data = &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE];
+
+	return 0;
+}
+#endif
+
+static struct snd_soc_dai_driver ar71xx_i2s_dai = {
+	//TODO check available formats on ar9331
+	.name	= "ar71xx-i2s",
+	.id	= 0,
+//	.probe	= ar71xx_i2s_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_44100 |
+		                SNDRV_PCM_RATE_48000 |
+		                SNDRV_PCM_RATE_88200 |
+		                SNDRV_PCM_RATE_96000,
+		.formats =	SNDRV_PCM_FMTBIT_S8 |
+				SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_S16_LE |
+				//TODO QCA driver says 32 bit is really noisy. has to be tested
+				SNDRV_PCM_FMTBIT_S24_BE |
+				SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_S32_BE |
+				SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates =	SNDRV_PCM_RATE_44100 |
+		                SNDRV_PCM_RATE_48000 |
+		                SNDRV_PCM_RATE_88200 |
+		                SNDRV_PCM_RATE_96000,
+		.formats =	SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S32_BE |
+				SNDRV_PCM_FMTBIT_S32_LE
+		},
+	.ops = &ar71xx_i2s_dai_ops,
+	.symmetric_rates = 1 //TODO whats this??
+};
+
+//TODO also in pcm file
+#if 0
+static bool ar71xx_i2s_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_CS_A_REG:
+	case AR71XX_I2S_FIFO_A_REG:
+	case AR71XX_I2S_INTSTC_A_REG:
+	case AR71XX_I2S_GRAY_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_i2s_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_I2S_FIFO_A_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+static bool ar71xx_clk_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case AR71XX_CLK_PCMCTL_REG:
+		return true;
+	default:
+		return false;
+	};
+}
+
+#endif
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	/* I2S Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_I2S_STEREO0_CLK_DIV,
+		//.precious_reg = ar71xx_i2s_precious_reg,
+		//.volatile_reg = ar71xx_i2s_volatile_reg,
+		.cache_type = REGCACHE_RBTREE,
+	},
+	/* GPIO Registers (only GPIO Function) */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR71XX_GPIO_FUNCTION,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+
+
+static const struct snd_soc_component_driver ar71xx_i2s_component = {
+	.name		= "ar71xx-i2s-comp",
+};
+
+static int ar71xx_i2s_probe(struct platform_device *pdev)
+{
+	struct ar71xx_i2s_dev *dev;
+	int i;
+	int ret;
+	struct regmap *regmap[2];
+	struct resource *mem[2];
+
+
+	/* Request ioareas */
+	for (i = 0; i < 2; i++) {
+		void __iomem *base;
+
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base,
+					    &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "I2S probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	}
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev),
+			   GFP_KERNEL);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+	dev->i2s_regmap = regmap[0];
+	dev->gpio_regmap = regmap[1];
+
+	/* Store the pdev */
+	dev->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, dev);
+
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&ar71xx_i2s_component, &ar71xx_i2s_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+
+	return 0;
+}
+
+static int ar71xx_i2s_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_i2s_driver = {
+	.probe		= ar71xx_i2s_probe,
+	.remove		= __exit_p(ar71xx_i2s_remove),
+	.driver		= {
+		.name	= "ar71xx-i2s",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_i2s_driver);
+
+MODULE_ALIAS("platform:ar71xx-i2s");
+MODULE_DESCRIPTION("AR71XX I2S interface");
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_GENERIC_DMAENGINE_PCM
 	select SND_SOC_DMAENGINE_PCM
 
 # All the supported SoCs
+source "sound/soc/ar71xx/Kconfig"
 source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/blackfin/Kconfig"
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -12,6 +12,7 @@ endif
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
 obj-$(CONFIG_SND_SOC)	+= codecs/
 obj-$(CONFIG_SND_SOC)	+= generic/
+obj-$(CONFIG_SND_SOC)	+= ar71xx/
 obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= blackfin/
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -105,6 +105,8 @@ int snd_soc_dai_set_clkdiv(struct snd_so
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, int source, unsigned int freq_in, unsigned int freq_out);
 
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int radio);
+
 /* Digital Audio interface formatting */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt);
 
@@ -131,6 +133,7 @@ struct snd_soc_dai_ops {
 	int (*set_pll)(struct snd_soc_dai *dai, int pll_id, int source,
 		unsigned int freq_in, unsigned int freq_out);
 	int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
+	int (*set_bclk_ratio)(struct snd_soc_dai *dai, unsigned int radio);
 
 	/*
 	 * DAI format configuration
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-i2s.h
@@ -0,0 +1,48 @@
+/*
+ * a71xx-i2s.h -- ALSA I2S interface
+ *
+ * ALSA SoC PCM Audio Layer for Atheros AR9331 SoC
+ *
+ * Copyright (c) 2014-2015 Felix Kramer <felixkramerroki@aol.com> All rights reserved
+ *
+ * <felixkramerroki@aol.com>
+ *
+ * Based on
+ *	ath79 QCA Audio Driver
+ *	Copyright (c) by Qualcom Atheros, Inc. 2013
+ *
+ *	Raspberry Pi I2S ALSA Driver
+ *	Copyright (c) by Florian Meier 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#ifndef AR71XX_I2S_H
+#define AR71XX_I2S_H
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+//TODO check if needed
+#include <sound/dmaengine_pcm.h>
+
+
+#endif /* AR71XX_I2S_H */
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3398,6 +3398,22 @@ int snd_soc_codec_set_sysclk(struct snd_
 EXPORT_SYMBOL_GPL(snd_soc_codec_set_sysclk);
 
 /**
+ * snd_soc_dai_set_bclk_ratio - configure BCLK to sample rate ratio.
+ * @dai: DAI
+ * @ratio: Rtio of BCLK to Sample rate.
+ *
+ * Configures the DAI for a preset BCLK to sample rate ratio
+ */
+int snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)
+{
+	if (dai->driver && dai->driver->ops->set_bclk_ratio)
+		return dai->driver->ops->set_bclk_ratio(dai, ratio);
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);
+
+/**
  * snd_soc_dai_set_clkdiv - configure DAI clock dividers.
  * @dai: DAI
  * @div_id: DAI specific clock divider ID
--- a/arch/mips/ath79/mach-carambola2.c
+++ b/arch/mips/ath79/mach-carambola2.c
@@ -10,6 +10,10 @@
 
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+
 #include "common.h"
 #include "dev-eth.h"
 #include "dev-gpio-buttons.h"
@@ -18,6 +22,7 @@
 #include "dev-spi.h"
 #include "dev-usb.h"
 #include "dev-wmac.h"
+#include "dev-pcm.h"
 #include "machtypes.h"
 
 #define CARAMBOLA2_GPIO_LED_WLAN		0
@@ -61,6 +66,81 @@ static struct gpio_keys_button carambola
 	},
 };
 
+#ifdef CONFIG_SND_SOC_AR71XX_PCM_MODULE
+static struct resource ar9331_pcm_resources[] = {
+	{
+		.start	= AR933X_MBOX_BASE,
+		.end	= AR933X_MBOX_BASE + AR933X_MBOX_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "mbox-registers-pcm"
+	},
+	{
+		.start	= AR933X_RST_RESET_BASE,
+		.end	= AR933X_RST_RESET_BASE + AR933X_RST_RESET_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "reset-registers-pcm"
+	},
+};
+
+static struct platform_device ar9331_pcm_device = {
+	.name		= "ar71xx-pcm",
+	.resource	= ar9331_pcm_resources,
+	.num_resources	= ARRAY_SIZE(ar9331_pcm_resources),
+};
+#endif
+
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+static struct resource ar9331_i2s_resources[] = {
+	{
+		.start	= AR933X_I2S_BASE,
+		.end	= AR933X_I2S_BASE + AR933X_I2S_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "i2s-registers-i2s"
+	},
+	{
+		.start	= AR71XX_GPIO_BASE,
+		.end	= AR71XX_GPIO_BASE + AR71XX_GPIO_SIZE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "gpio-registers-i2s"
+	}
+};
+
+static struct platform_device ar9331_i2s_device = {
+	.name		= "ar71xx-i2s",
+	.resource	= ar9331_i2s_resources,
+	.num_resources	= ARRAY_SIZE(ar9331_i2s_resources),
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+static struct platform_device snd_hifiberry_dac_device = {
+	.name 		= "snd-hifiberry-dac",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static struct platform_device snd_pcm5102a_codec_device = {
+	.name		= "pcm5102a-codec",
+	.id		= -1,
+	.num_resources	= 0,
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_TAS5711_EVB) || defined(CONFIG_SND_SOC_AR71XX_TAS5711_EVB_MODULE)
+static struct platform_device snd_tas5711_evb_device = {
+	.name 		= "snd-tas5711-evb",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+//TODO propably not working
+static struct i2c_board_info __initdata snd_tas5711_i2c_devices[] = {
+        {
+                I2C_BOARD_INFO("tas5711", 0x1b)
+        },
+};
+#endif
+
 static void __init carambola2_common_setup(void)
 {
 	u8 *art = (u8 *) KSEG1ADDR(0x1fff0000);
@@ -81,6 +161,28 @@ static void __init carambola2_common_set
 
 	/* WAN port */
 	ath79_register_eth(0);
+
+#ifdef CONFIG_SND_SOC_AR71XX_PCM_MODULE
+	/* PCM module */
+	ath79_register_pcm(&ar9331_pcm_device);
+#endif
+
+#ifdef CONFIG_SND_SOC_AR71XX_I2S_MODULE
+	/* I2S module */
+	ath79_register_pcm(&ar9331_i2s_device);
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC) || defined(CONFIG_SND_SOC_AR71XX_HIFIBERRY_DAC_MODULE)
+	/* Hifiberry dac module */
+	ath79_register_pcm(&snd_hifiberry_dac_device);
+	ath79_register_pcm(&snd_pcm5102a_codec_device);
+#endif
+
+#if defined(CONFIG_SND_SOC_AR71XX_TAS5711_EVB) || defined(CONFIG_SND_SOC_AR71XX_TAS5711_EVB_MODULE)
+	/* TAS5711 Evaluation Board  module */
+        ath79_register_pcm(&snd_tas5711_evb_device);
+        i2c_register_board_info(1, snd_tas5711_i2c_devices, ARRAY_SIZE(snd_tas5711_i2c_devices));
+#endif
 }
 
 static void __init carambola2_setup(void)
--- a/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
+++ b/arch/mips/include/asm/mach-ath79/ar71xx_regs.h
@@ -94,6 +94,16 @@
 #define AR933X_WMAC_SIZE	0x20000
 #define AR933X_EHCI_BASE	0x1b000000
 #define AR933X_EHCI_SIZE	0x1000
+#define AR933X_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
+#define AR933X_RESET_SIZE	0xb0
+#define AR933X_RST_RESET_BASE	(AR71XX_APB_BASE + 0x0006001c)
+#define AR933X_RST_RESET_SIZE	0x00
+#define AR933X_RST_MISC_INT_BASE	(AR71XX_APB_BASE + 0x00060010)
+#define AR933X_RST_MISC_INT_SIZE	0x04
+#define AR933X_I2S_BASE		(AR71XX_APB_BASE + 0x000B0000)
+#define AR933X_I2S_SIZE		0x20
+#define AR933X_MBOX_BASE	(AR71XX_APB_BASE + 0x000A0000)
+#define AR933X_MBOX_SIZE	0x58
 
 #define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
 #define AR934X_GMAC_SIZE	0x14
--- a/arch/mips/ath79/Kconfig
+++ b/arch/mips/ath79/Kconfig
@@ -1014,6 +1014,7 @@ config ATH79_MACH_CARAMBOLA2
 	select ATH79_DEV_M25P80
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
+	select ATH79_DEV_PCM
 
 config ATH79_MACH_BHU_BXU2000N2_A
 	bool "BHU BXU2000n-2 rev. A support"
@@ -1100,6 +1101,9 @@ config ATH79_DEV_SPI
 config ATH79_DEV_USB
 	def_bool n
 
+config ATH79_DEV_PCM
+	def_bool n
+
 config ATH79_DEV_WMAC
 	depends on (SOC_AR913X || SOC_AR933X || SOC_AR934X || SOC_QCA953X || SOC_QCA955X)
 	def_bool n
--- a/arch/mips/ath79/Makefile
+++ b/arch/mips/ath79/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_ATH79_DEV_NFC)		+= dev-nfc.
 obj-$(CONFIG_ATH79_DEV_SPI)		+= dev-spi.o
 obj-$(CONFIG_ATH79_DEV_USB)		+= dev-usb.o
 obj-$(CONFIG_ATH79_DEV_WMAC)		+= dev-wmac.o
+obj-$(CONFIG_ATH79_DEV_PCM)		+= dev-pcm.o
 
 #
 # Miscellaneous objects
--- /dev/null
+++ b/sound/soc/ar71xx/hifiberry_dac.c
@@ -0,0 +1,117 @@
+/*
+ * ASoC Driver for HifiBerry DAC
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * TODO:
+ * - CPU DAI Name
+ * - Platform Name
+ *
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+
+static int snd_rpi_hifiberry_dac_init(struct snd_soc_pcm_runtime *rtd)
+{
+	printk("in dac_init\n");
+	return 0;
+}
+
+static int snd_rpi_hifiberry_dac_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	unsigned int sample_bits =
+		snd_pcm_format_physical_width(params_format(params));
+	unsigned int fmt = 1;//TODO
+
+	printk("in dac_hw_params\n");
+	
+
+	//return snd_soc_dai_set_bclk_ratio(cpu_dai, sample_bits * 2);
+	//return snd_soc_dai_set_fmt(cpu_dai, fmt);
+	return 0;
+}
+
+/* machine stream operations */
+static struct snd_soc_ops snd_rpi_hifiberry_dac_ops = {
+	.hw_params = snd_rpi_hifiberry_dac_hw_params,
+};
+
+static struct snd_soc_dai_link snd_rpi_hifiberry_dac_dai[] = {
+{
+	.name		= "HifiBerry DAC",
+	.stream_name	= "HifiBerry DAC HiFi",
+	.cpu_dai_name	= "ar71xx-i2s.0",
+	.codec_dai_name	= "pcm5102a-hifi",
+	.platform_name	= "ar71xx-pcm.0",
+	.codec_name	= "pcm5102a-codec",
+	.dai_fmt	= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				SND_SOC_DAIFMT_CBS_CFS,
+	.ops		= &snd_rpi_hifiberry_dac_ops,
+	.init		= snd_rpi_hifiberry_dac_init,
+},
+};
+
+/* audio machine driver */
+static struct snd_soc_card snd_rpi_hifiberry_dac = {
+	.name         = "snd_carambola2_hifiberry_dac",
+	.dai_link     = snd_rpi_hifiberry_dac_dai,
+	.num_links    = ARRAY_SIZE(snd_rpi_hifiberry_dac_dai),
+};
+
+static int snd_rpi_hifiberry_dac_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	dev_info(&pdev->dev, "in ..._dac_probe()\n");
+
+	snd_rpi_hifiberry_dac.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_rpi_hifiberry_dac);
+	if (ret)
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+
+	return ret;
+}
+
+static int snd_rpi_hifiberry_dac_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "in ..._dac_remove()\n");
+
+	return snd_soc_unregister_card(&snd_rpi_hifiberry_dac);
+}
+
+static struct platform_driver snd_rpi_hifiberry_dac_driver = {
+        .driver = {
+                .name   = "snd-hifiberry-dac",
+                .owner  = THIS_MODULE,
+        },
+        .probe          = snd_rpi_hifiberry_dac_probe,
+        .remove         = snd_rpi_hifiberry_dac_remove,
+};
+
+module_platform_driver(snd_rpi_hifiberry_dac_driver);
+
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_DESCRIPTION("ASoC Driver for HifiBerry DAC");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -55,6 +55,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ML26124 if I2C
 	select SND_SOC_OMAP_HDMI_CODEC if OMAP4_DSS_HDMI
 	select SND_SOC_PCM3008
+	select SND_SOC_PCM5102A
 	select SND_SOC_RT5631 if I2C
 	select SND_SOC_SGTL5000 if I2C
 	select SND_SOC_SI476X if MFD_SI476X_CORE
@@ -65,6 +66,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_STA529 if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TAS5086 if I2C
+	select SND_SOC_TAS5711 if I2C
 	select SND_SOC_TLV320AIC23 if I2C
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
 	select SND_SOC_TLV320AIC32X4 if I2C
@@ -293,6 +295,9 @@ config SND_SOC_OMAP_HDMI_CODEC
 config SND_SOC_PCM3008
        tristate
 
+config SND_SOC_PCM5102A
+       tristate
+
 config SND_SOC_RT5631
 	tristate
 
@@ -328,6 +333,9 @@ config SND_SOC_STAC9766
 config SND_SOC_TAS5086
 	tristate
 
+config SND_SOC_TAS5711
+	tristate
+
 config SND_SOC_TLV320AIC23
 	tristate
 
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -43,6 +43,7 @@ snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-omap-hdmi-codec-objs := omap-hdmi.o
 snd-soc-pcm3008-objs := pcm3008.o
+snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-rt5631-objs := rt5631.o
 snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-alc5623-objs := alc5623.o
@@ -57,6 +58,7 @@ snd-soc-sta32x-objs := sta32x.o
 snd-soc-sta529-objs := sta529.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tas5086-objs := tas5086.o
+snd-soc-tas5711-objs := tas5711.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic26-objs := tlv320aic26.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
@@ -170,6 +172,7 @@ obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_OMAP_HDMI_CODEC) += snd-soc-omap-hdmi-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
+obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
 obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
 obj-$(CONFIG_SND_SOC_SGTL5000)  += snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_SIGMADSP)	+= snd-soc-sigmadsp.o
@@ -181,6 +184,7 @@ obj-$(CONFIG_SND_SOC_STA32X)   += snd-so
 obj-$(CONFIG_SND_SOC_STA529)   += snd-soc-sta529.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
+obj-$(CONFIG_SND_SOC_TAS5711)	+= snd-soc-tas5711.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC26)	+= snd-soc-tlv320aic26.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
--- /dev/null
+++ b/sound/soc/codecs/pcm5102a.c
@@ -0,0 +1,73 @@
+/*
+ * Driver for the PCM5102A codec
+ *
+ * Author:	Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/soc.h>
+
+static struct snd_soc_dai_driver pcm5102a_dai = {
+	.name = "pcm5102a-hifi",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   // SNDRV_PCM_FMTBIT_S24_LE | : disable for now, it causes white noise with xbmc
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE | 
+			   SNDRV_PCM_FMTBIT_S32_LE
+	},
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_pcm5102a;
+
+static int pcm5102a_probe(struct platform_device *pdev)
+{
+	printk("in pcm5102a_probe()\ndoing snd_soc_register_codec() now\n");
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pcm5102a,
+			&pcm5102a_dai, 1);
+}
+
+static int pcm5102a_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver pcm5102a_codec_driver = {
+	.probe 		= pcm5102a_probe,
+	.remove 	= pcm5102a_remove,
+	.driver		= {
+		.name	= "pcm5102a-codec",
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(pcm5102a_codec_driver);
+
+MODULE_DESCRIPTION("ASoC PCM5102A codec driver");
+MODULE_AUTHOR("Florian Meier <florian.meier@koalo.de>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-mbox.c
@@ -0,0 +1,317 @@
+/*
+ * a71xx-mbox.c -- AR9331 MBOX functions
+ *
+ * ALSA SoC PCM Audio Layer for Atheros AR9331 SoC
+ *
+ * Copyright (c) 2014-2015 Felix Kramer <felixkramerroki@aol.com> All rights reserved
+ *
+ * <felixkramerroki@aol.com>
+ *
+ * Based on
+ *	ath79 QCA Audio Driver
+ *	Copyright (c) by Qualcom Atheros, Inc. 2013
+ *
+ *	Raspberry Pi I2S ALSA Driver
+ *	Copyright (c) by Florian Meier 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/types.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#include "ar71xx-pcm.h"
+
+#define AR71XX_MBOX_DEBUG_MESSAGES	0
+
+spinlock_t ar71xx_pcm_lock;
+static struct dma_pool *ar71xx_pcm_cache;
+
+void ar71xx_mbox_reset(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	//TODO spin_lock needed?
+	spin_lock(&ar71xx_pcm_lock);
+
+	regmap_update_bits(dev->reset_regmap,
+			AR9331_RESET_RST_RESET,
+			AR9331_RESET_RST_RESET_MBOX,
+			AR9331_RESET_RST_RESET_MBOX);
+
+	//t = ar71xx_reset_rr(AR934X_RESET_REG_RESET_MODULE);
+	//t |= AR934X_RESET_MBOX;
+	//ath79_reset_wr(AR934X_RESET_REG_RESET_MODULE, t);
+
+	udelay(50);
+	//t &= ~(AR934X_RESET_MBOX);
+	//ath79_reset_wr(AR934X_RESET_REG_RESET_MODULE, t);
+	regmap_update_bits(dev->reset_regmap,
+			AR9331_RESET_RST_RESET,
+			AR9331_RESET_RST_RESET_MBOX, 0);
+
+	spin_unlock(&ar71xx_pcm_lock);
+}
+
+void ar71xx_mbox_fifo_reset(bool rx, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	if (rx) {
+	regmap_update_bits(dev->mbox_regmap,
+			AR9331_MBOX_DMA_FIFO_RESET,
+			AR9331_MBOX_DMA_FIFO_RESET_RX_INIT,
+			AR9331_MBOX_DMA_FIFO_RESET_RX_INIT);
+	} else {
+	regmap_update_bits(dev->mbox_regmap,
+			AR9331_MBOX_DMA_FIFO_RESET,
+			AR9331_MBOX_DMA_FIFO_RESET_TX_INIT,
+			AR9331_MBOX_DMA_FIFO_RESET_TX_INIT);
+	}
+
+	udelay(50);
+}
+
+void ar71xx_mbox_interrupt_enable(u32 mask, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	spin_lock(&ar71xx_pcm_lock);
+
+	regmap_write(dev->mbox_regmap, AR9331_MBOX_INT_ENABLE,
+			mask);
+
+	spin_unlock(&ar71xx_pcm_lock);
+}
+
+void ar71xx_mbox_interrupt_ack(u32 mask, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+
+	regmap_write(dev->mbox_regmap, AR9331_MBOX_INT_STATUS, mask);
+
+	/* Flush the register */
+	regmap_read(dev->mbox_regmap, AR9331_MBOX_INT_STATUS, &reg);
+
+}
+
+void ar71xx_mbox_dma_rx_resume(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+
+	regmap_write(dev->mbox_regmap,
+		AR9331_MBOX_DMA_RX_CONTROL,
+		AR9331_MBOX_DMA_CONTROL_RESUME);
+	regmap_read(dev->mbox_regmap,
+		AR9331_MBOX_DMA_RX_CONTROL, &reg);
+}
+
+void ar71xx_mbox_dma_start(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+#define TIMER_VAL	100
+	u32 reg;
+	int timer;
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_write(dev->mbox_regmap,
+			AR9331_MBOX_DMA_RX_CONTROL,
+			AR9331_MBOX_DMA_CONTROL_START);
+
+		/* wait until command is received */
+		for(timer = TIMER_VAL; timer > 0; timer--) {
+			regmap_read(dev->mbox_regmap,
+				AR9331_MBOX_DMA_RX_CONTROL, &reg);
+			if(!reg)
+				break;
+		}
+	} else {
+		regmap_write(dev->mbox_regmap,
+			AR9331_MBOX_DMA_TX_CONTROL,
+			AR9331_MBOX_DMA_CONTROL_START);
+
+		for(timer = TIMER_VAL; timer > 0; timer--) {
+			regmap_read(dev->mbox_regmap,
+				AR9331_MBOX_DMA_TX_CONTROL, &reg);
+			if(!reg)
+				break;
+		}
+	}
+#undef TIMER_VAL
+}
+
+void ar71xx_mbox_dma_stop(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	u32 reg;
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_write(dev->mbox_regmap,
+			AR9331_MBOX_DMA_RX_CONTROL,
+			AR9331_MBOX_DMA_CONTROL_STOP);
+		regmap_read(dev->mbox_regmap,
+			AR9331_MBOX_DMA_RX_CONTROL, &reg);
+	} else {
+		regmap_write(dev->mbox_regmap,
+			AR9331_MBOX_DMA_TX_CONTROL,
+			AR9331_MBOX_DMA_CONTROL_STOP);
+		regmap_read(dev->mbox_regmap,
+			AR9331_MBOX_DMA_TX_CONTROL, &reg);
+	}
+
+	/* Delay for the dynamically calculated max time based on
+	sample size, channel, sample rate + margin to ensure that the
+	DMA engine will be truly idle. */
+	mdelay(rtpriv->delay_time);
+}
+
+void ar71xx_mbox_dma_reset(struct ar71xx_pcm_pltfm_priv *dev)
+{
+	ar71xx_mbox_reset(dev);
+
+	/* reset both fifos */
+	ar71xx_mbox_fifo_reset(true, dev);
+	ar71xx_mbox_fifo_reset(false, dev);
+}
+
+void ar71xx_mbox_dma_prepare(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev)
+{
+	struct ar71xx_pcm_desc *desc;
+
+	/* first kill all interrupts */
+	regmap_write(dev->mbox_regmap, AR9331_MBOX_INT_ENABLE, 0x00);
+
+	if (rtpriv->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Request the DMA channel to the controller */
+		regmap_update_bits(dev->mbox_regmap,
+				AR9331_MBOX_DMA_POLICY,
+				AR9331_MBOX_DMA_POLICY_RX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6),
+				AR9331_MBOX_DMA_POLICY_RX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6));
+
+		/* The direction is indicated from the DMA engine perspective
+		 * i.e. we'll be using the RX registers for Playback and
+		 * the TX registers for capture */
+		desc = list_first_entry(&rtpriv->dma_head, struct ar71xx_pcm_desc, list);
+		//TODO check this
+		//regmap_read(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, &reg);
+		//desc->phys = reg;
+		regmap_write(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, (u32)desc->phys);
+		ar71xx_mbox_interrupt_enable(AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE, dev);
+	} else {
+		/* Request the DMA channel to the controller */
+		regmap_update_bits(dev->mbox_regmap,
+				AR9331_MBOX_DMA_POLICY,
+				AR9331_MBOX_DMA_POLICY_TX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6),
+				AR9331_MBOX_DMA_POLICY_TX_QUANTUM |
+				AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(6));
+
+		desc = list_first_entry(&rtpriv->dma_head, struct ar71xx_pcm_desc, list);
+		//regmap_read(dev->mbox_regmap, AR9331_MBOX_DMA_TX_DESCRIPTOR_BASE, &reg);
+		//desc->phys = reg;
+		regmap_write(dev->mbox_regmap, AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE, (u32)desc->phys);
+		ar71xx_mbox_interrupt_enable(AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE, dev);
+	}
+}
+
+int ar71xx_mbox_dma_map(struct ar71xx_pcm_rt_priv *rtpriv, dma_addr_t baseaddr,
+			      int period_bytes, int bufsize)
+{
+	struct list_head *head = &rtpriv->dma_head;
+	struct ar71xx_pcm_desc *desc, *prev;
+	dma_addr_t desc_p;
+	unsigned int offset = 0;
+
+	spin_lock(&ar71xx_pcm_lock);
+
+	rtpriv->elapsed_size = 0;
+	/* We loop until we have enough buffers to map the requested DMA area */
+	do {
+		/* Allocate a descriptor and insert it into the DMA ring */
+		desc = dma_pool_alloc(ar71xx_pcm_cache, GFP_KERNEL, &desc_p);
+		if(!desc) {
+			return -ENOMEM;
+		}
+		memset(desc, 0, sizeof(struct ar71xx_pcm_desc));
+		desc->phys = desc_p;
+		list_add_tail(&desc->list, head);
+
+		desc->OWN = 1;
+
+		desc->rsvd1 = desc->rsvd2 = desc->rsvd3 = desc->EOM = 0;
+
+		/* buffer size may not be a multiple of period_bytes */
+		if (bufsize >= offset + period_bytes) {
+			desc->size = period_bytes;
+		} else {
+			desc->size = bufsize - offset;
+		}
+		desc->BufPtr = baseaddr + offset;
+
+		/* For now, we assume the buffer is always full
+		 * -->length == size */
+		desc->length = desc->size;
+
+		/* We need to make sure we are not the first descriptor.
+		 * If we are, prev doesn't point to a struct ar71xx_pcm_desc */
+		if (desc->list.prev != head) {
+			prev =
+			    list_entry(desc->list.prev, struct ar71xx_pcm_desc,
+				       list);
+			prev->NextPtr = desc->phys;
+		}
+
+		offset += desc->size;
+
+	} while (offset < bufsize);
+
+	/* Once all the descriptors have been created, we can close the loop
+	 * by pointing from the last one to the first one */
+	desc = list_first_entry(head, struct ar71xx_pcm_desc, list);
+	prev = list_entry(head->prev, struct ar71xx_pcm_desc, list);
+	prev->NextPtr = desc->phys;
+
+	spin_unlock(&ar71xx_pcm_lock);
+
+	return 0;
+}
+
+void ar71xx_mbox_dma_unmap(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct list_head *head = &rtpriv->dma_head;
+	struct ar71xx_pcm_desc *desc, *n;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry_safe(desc, n, head, list) {
+		list_del(&desc->list);
+		dma_pool_free(ar71xx_pcm_cache, desc, desc->phys);
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+
+	return;
+}
+
+int ar71xx_mbox_dma_init(struct device *dev)
+{
+	int ret = 0;
+
+	/* Allocate a DMA pool to store the MBOX descriptor */
+	ar71xx_pcm_cache = dma_pool_create("ar71xx_pcm_pool", dev,
+					 sizeof(struct ar71xx_pcm_desc), 4, 0);
+	if (!ar71xx_pcm_cache)
+		ret = -ENOMEM;
+
+	return ret;
+}
+
+void ar71xx_mbox_dma_exit(void)
+{
+	dma_pool_destroy(ar71xx_pcm_cache);
+	ar71xx_pcm_cache = NULL;
+}
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-pcm.c
@@ -0,0 +1,538 @@
+/*
+ * a71xx-pcm.c -- AR9331 PCM Interface
+ *
+ * ALSA SoC PCM Audio Layer for Atheros AR9331 SoC
+ *
+ * Copyright (c) 2014-2015 Felix Kramer <felixkramerroki@aol.com> All rights reserved
+ *
+ * <felixkramerroki@aol.com>
+ *
+ * Based on
+ *	ath79 QCA Audio Driver
+ *	Copyright (c) by Qualcom Atheros, Inc. 2013
+ *
+ *	Raspberry Pi I2S ALSA Driver
+ *	Copyright (c) by Florian Meier 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include "ar71xx-pcm.h"
+
+#define BUFFER_BYTES_MAX 16 * 4095 * 16
+#define PERIOD_BYTES_MIN 64
+
+#define AR71XX_PCM_DEBUG	0
+
+
+static struct snd_pcm_hardware ar71xx_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,
+	.formats = SNDRV_PCM_FMTBIT_S8 |
+			SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_BE | SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = SNDRV_PCM_RATE_22050 |
+			SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000 |
+			SNDRV_PCM_RATE_88200 |
+			SNDRV_PCM_RATE_96000,
+	.rate_min = 22050,
+	.rate_max = 96000,
+	.channels_min = 2,
+	.channels_max = 2,
+	/* These numbers are empirical. As the DMA engine is descriptor base
+	 * the only real limitation we have is the amount of RAM.
+	 * Ideally, we'd need to find the best tradeoff between number of descs
+	 * and CPU load */
+
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = 4095,
+	.periods_min = 16,
+	.periods_max = 256,
+	.fifo_size = 0,
+};
+
+static irqreturn_t ar71xx_pcm_interrupt(int irq, void *dev_id)
+{
+	uint32_t status;
+	struct ar71xx_pcm_pltfm_priv *prdata = dev_id;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	unsigned int period_bytes;
+
+
+	regmap_read(prdata->mbox_regmap, AR9331_MBOX_INT_STATUS, &status);
+
+	/*
+	 * 1 Frame = channels * bitnumber
+	 * eg: 2 chnls * 16 Bit = 4 Bytes
+	 *
+	 * period: number of frames between HW interrupts
+	 */
+
+	/* RX DMA is enabled */
+	if(status & AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE) {
+		unsigned int played_size;
+		rtpriv = prdata->playback->runtime->private_data;
+
+		/* Store the last played buffer in the runtime priv struct */
+		rtpriv->last_played = ar71xx_pcm_get_last_played(rtpriv);
+		period_bytes = snd_pcm_lib_period_bytes(prdata->playback);
+
+		played_size = ar71xx_pcm_set_own_bits(rtpriv);
+
+
+		if(played_size > period_bytes)
+			printk("Played more than one period, bytes played: %d\n",played_size);
+
+		rtpriv->elapsed_size += played_size;
+		ar71xx_mbox_interrupt_ack(AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE, prdata);
+
+
+		if(rtpriv->elapsed_size >= period_bytes)
+		{
+			rtpriv->elapsed_size %= period_bytes;
+			snd_pcm_period_elapsed(prdata->playback);
+		}
+
+		if (rtpriv->last_played == NULL) {
+			printk("BUG: ISR called but no played buf found\n");
+			goto ack;
+		}
+	}
+
+	if(status & AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE) {
+		rtpriv = prdata->capture->runtime->private_data;
+
+		/* Store the last played buffer in the runtime priv struct */
+		rtpriv->last_played = ar71xx_pcm_get_last_played(rtpriv);
+		ar71xx_pcm_set_own_bits(rtpriv);
+		ar71xx_mbox_interrupt_ack(AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE, prdata);
+
+		if (rtpriv->last_played == NULL) {
+			printk("BUG: ISR called but no rec buf found\n");
+			goto ack;
+		}
+		snd_pcm_period_elapsed(prdata->capture);
+	}
+ack:
+	return IRQ_HANDLED;
+}
+
+static int ar71xx_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *runtime = ss->private_data;
+	struct snd_soc_platform *platform = runtime->platform;
+	struct ar71xx_pcm_pltfm_priv *prdata = snd_soc_platform_get_drvdata(platform);
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	int err;
+
+	if (!prdata->irq_en) {
+		err = request_irq(ATH79_MISC_IRQ(7), ar71xx_pcm_interrupt, 0,
+				  "ar71xx-pcm-interrupt", prdata);
+
+		if (err) {
+			//TODO kfree needed?
+			//kfree(prdata);
+			return -EBUSY;
+		}
+		prdata->irq_en = true;
+	}
+
+
+	/* setup substream */
+	if (ss->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prdata->playback = ss;
+	} else {
+		prdata->capture = ss;
+	}
+
+	/* Allocate/Initialize the buffer linked list head */
+	rtpriv = kmalloc(sizeof(*rtpriv), GFP_KERNEL);
+	if (!rtpriv) {
+		return -ENOMEM;
+	}
+#if 0
+	snd_printd("%s: 0x%xB allocated at 0x%08x\n",
+	       __FUNCTION__, sizeof(*rtpriv), (u32) rtpriv);
+#else
+	printk("%s: 0x%xB allocated at 0x%08x\n",
+	       __FUNCTION__, sizeof(*rtpriv), (u32) rtpriv);
+#endif
+
+	ss->runtime->private_data = rtpriv;
+	rtpriv->last_played = NULL;
+	INIT_LIST_HEAD(&rtpriv->dma_head);
+
+	/* TODO could be in previous if sequence ?? */
+	if(ss->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtpriv->direction = SNDRV_PCM_STREAM_PLAYBACK;
+	else
+		rtpriv->direction = SNDRV_PCM_STREAM_CAPTURE;
+
+	snd_soc_set_runtime_hwparams(ss, &ar71xx_pcm_hardware);
+
+	return 0;
+}
+
+static int ar71xx_pcm_close(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *runtime = ss->private_data;
+	struct snd_soc_platform *platform = runtime->platform;
+	struct ar71xx_pcm_pltfm_priv *prdata = snd_soc_platform_get_drvdata(platform);
+	struct ar71xx_pcm_rt_priv *rtpriv;
+
+	if (!prdata)
+		return 0;
+
+	if (ss->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prdata->playback = NULL;
+	} else {
+		prdata->capture = NULL;
+	}
+
+	if (!prdata->playback && !prdata->capture) {
+		free_irq(ATH79_MISC_IRQ(7), prdata);
+		prdata->irq_en = false;
+	}
+	rtpriv = ss->runtime->private_data;
+	kfree(rtpriv);
+
+	return 0;
+}
+
+static int ar71xx_pcm_hw_params(struct snd_pcm_substream *ss,
+			      struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+	int ret;
+	unsigned int frames, sample_rate, period_size;
+	unsigned int sample_size, channels;
+
+	//TODO Does this routine need to handle new clock changes in the hw_params?
+	rtpriv = runtime->private_data;
+
+	ret = ar71xx_mbox_dma_map(rtpriv, ss->dma_buffer.addr,
+		params_period_bytes(hw_params), params_buffer_bytes(hw_params));
+
+	if(ret < 0)
+		return ret;
+
+	channels = params_channels(hw_params);
+	sample_rate = params_rate(hw_params);
+	period_size = params_period_bytes(hw_params);
+	sample_size = snd_pcm_format_size(params_format(hw_params), 1);
+	frames = period_size / (sample_size * channels);
+
+#if AR71XX_PCM_DEBUG
+	unsigned int buffer_size;
+
+	buffer_size = params_buffer_bytes(hw_params);
+
+	printk("parameters:\nperiod_size\t->\t%d\nsample_size\t->\t%d\nsample_rate\t->\t%d\nchannels\t\t->\t%d\nframes\t\t->\t%d\nbuffer_size\t->\t%d\n", period_size, sample_size, sample_rate, channels, frames, buffer_size);
+#endif
+
+/* 	When we disbale the DMA engine, it could be just at the start of a descriptor.
+	Hence calculate the longest time the DMA engine could be grabbing bytes for to
+	Make sure we do not unmap the memory before the DMA is complete.
+	Add 10 mSec of margin. This value will be used in ath79_mbox_dma_stop */
+
+	rtpriv->delay_time = (frames * 1000)/sample_rate + 10;
+
+	snd_pcm_set_runtime_buffer(ss, &ss->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(hw_params);
+
+	return 1;
+}
+
+static int ar71xx_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+
+	rtpriv = runtime->private_data;
+	ar71xx_mbox_dma_unmap(rtpriv);
+	snd_pcm_set_runtime_buffer(ss, NULL);
+
+	return 0;
+}
+
+static int ar71xx_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+	struct snd_soc_dai *cpu_dai;
+	struct ar71xx_pcm_rt_priv *rtpriv;
+
+	struct snd_soc_platform *platform = rtd->platform;
+	struct ar71xx_pcm_pltfm_priv *dev = dev_get_drvdata(platform->dev);
+
+	rtpriv = runtime->private_data;
+	cpu_dai = rtd->cpu_dai;
+
+	/* When setup the first stream should reset the DMA MBOX controller */
+	if(cpu_dai->active == 1) {
+		ar71xx_mbox_dma_reset(dev);
+	}
+
+	ar71xx_mbox_dma_prepare(rtpriv, dev);
+
+	ar71xx_pcm_set_own_bits(rtpriv);
+	rtpriv->last_played = NULL;
+
+	return 0;
+}
+
+static int ar71xx_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	struct ar71xx_pcm_rt_priv *rtpriv = ss->runtime->private_data;
+
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct ar71xx_pcm_pltfm_priv *dev = dev_get_drvdata(platform->dev);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ar71xx_mbox_dma_start(rtpriv, dev);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ar71xx_mbox_dma_stop(rtpriv, dev);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t ar71xx_pcm_pointer(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct ar71xx_pcm_rt_priv *rtpriv = runtime->private_data;
+	snd_pcm_uframes_t ret = 0;
+
+	if(rtpriv->last_played == NULL) {
+		ret = 0;
+	} else {
+		ret = rtpriv->last_played->BufPtr - runtime->dma_addr;
+		ret = bytes_to_frames(runtime, ret);
+	}
+
+
+	return ret;
+}
+
+static int ar71xx_pcm_mmap(struct snd_pcm_substream *ss, struct vm_area_struct *vma)
+{
+	return remap_pfn_range(vma, vma->vm_start,
+			ss->dma_buffer.addr >> PAGE_SHIFT,
+			vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
+static struct snd_pcm_ops ar71xx_pcm_ops = {
+	.open		= ar71xx_pcm_open,
+	.close		= ar71xx_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= ar71xx_pcm_hw_params,
+	.hw_free	= ar71xx_pcm_hw_free,
+	.prepare	= ar71xx_pcm_prepare,
+	.trigger	= ar71xx_pcm_trigger,
+	.pointer	= ar71xx_pcm_pointer,
+	.mmap		= ar71xx_pcm_mmap,
+};
+
+static void ar71xx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *ss;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		ss = pcm->streams[stream].substream;
+		if (!ss)
+			continue;
+		buf = &ss->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_coherent(NULL, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+
+	ar71xx_mbox_dma_exit();
+}
+
+static int ar71xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *ss = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &ss->dma_buffer;
+
+	printk(KERN_NOTICE "%s: allocate %8s stream\n", __FUNCTION__,
+		stream == SNDRV_PCM_STREAM_CAPTURE ? "capture" : "playback" );
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->bytes = ar71xx_pcm_hardware.buffer_bytes_max;
+
+	buf->area = dma_alloc_coherent(NULL, buf->bytes,
+					   &buf->addr, GFP_DMA);
+	if (!buf->area)
+		return -ENOMEM;
+
+	printk(KERN_NOTICE "%s: 0x%xB allocated at 0x%08x\n",
+		__FUNCTION__, buf->bytes, (u32) buf->area);
+
+	return 0;
+}
+
+static u64 ar71xx_pcm_dmamask = 0xffffffff;
+
+static int ar71xx_soc_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &ar71xx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = ar71xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = ar71xx_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+	ar71xx_mbox_dma_init(rtd->platform->dev);
+
+out:
+	return ret;
+}
+
+struct snd_soc_platform_driver ar71xx_soc_platform = {
+	.ops		= &ar71xx_pcm_ops,
+	.pcm_new	= ar71xx_soc_pcm_new,
+	.pcm_free	= ar71xx_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(ar71xx_soc_platform);
+
+
+static const struct regmap_config ar71xx_regmap_config[] = {
+	/* MBOX DMA Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR9331_SLIC_MBOX_DMA_FIFO_RESET,
+		.cache_type = REGCACHE_NONE,
+		//.cache_type = REGCACHE_RBTREE,
+	},
+	/* Reset Registers */
+	{
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = AR9331_RESET_RST_RESET,
+		.cache_type = REGCACHE_RBTREE,
+	},
+};
+
+static int ar71xx_pcm_probe(struct platform_device *pdev)
+{
+	struct ar71xx_pcm_pltfm_priv *prdata;
+	int ret, i;
+	struct regmap *regmap[2];
+	struct resource *mem[2];
+
+	/* Request ioarea */
+	for (i = 0; i < 2; i++) {
+		void __iomem *base;
+
+		mem[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
+
+		base = devm_ioremap_resource(&pdev->dev, mem[i]);
+		if (IS_ERR(base))
+			return PTR_ERR(base);
+
+		regmap[i] = devm_regmap_init_mmio(&pdev->dev, base,
+					    &ar71xx_regmap_config[i]);
+		if (IS_ERR(regmap[i])) {
+			dev_err(&pdev->dev, "PCM probe: regmap init failed\n");
+			return PTR_ERR(regmap[i]);
+		}
+	}
+
+	prdata = kzalloc(sizeof(struct ar71xx_pcm_pltfm_priv), GFP_KERNEL);
+	if (prdata == NULL)
+		return -ENOMEM;
+
+	prdata->mbox_regmap = regmap[0];
+	prdata->reset_regmap = regmap[1];
+
+	/* interrupt not yet enabled */
+	prdata->irq_en = false;
+
+	prdata->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, prdata);
+
+	ret = snd_soc_register_platform(&pdev->dev, &ar71xx_soc_platform);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register platform: %d\n", ret);
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ar71xx_pcm_remove(struct platform_device *pdev)
+{
+	struct ar71xx_pcm_pltfm_priv *prdata = dev_get_drvdata(&pdev->dev);
+
+	printk("in pcm remove\n");
+
+	kfree(prdata);
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ar71xx_pcm_driver = {
+	.probe 		= ar71xx_pcm_probe,
+	.remove 	= __exit_p(ar71xx_pcm_remove),
+	.driver 	= {
+		.name 	= "ar71xx-pcm",
+		.owner 	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(ar71xx_pcm_driver);
+
+MODULE_ALIAS("platform:ar71xx-pcm");
+MODULE_DESCRIPTION("AR71XX PCM Interface");
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/ar71xx/ar71xx-pcm.h
@@ -0,0 +1,203 @@
+/*
+ * a71xx-pcm.h -- AR9331 PCM Interface
+ *
+ * ALSA SoC PCM Audio Layer for Atheros AR9331 SoC
+ *
+ * Copyright (c) 2014-2015 Felix Kramer <felixkramerroki@aol.com> All rights reserved
+ *
+ * <felixkramerroki@aol.com>
+ *
+ * Based on
+ *	ath79 QCA Audio Driver
+ *	Copyright (c) by Qualcom Atheros, Inc. 2013
+ *
+ *	Raspberry Pi I2S ALSA Driver
+ *	Copyright (c) by Florian Meier 2013
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#ifndef AR71XX_PCM_H
+#define AR71XX_PCM_H
+
+
+#include <linux/sound.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+/* MBOX REGISTERS */
+#define AR9331_MBOX_DMA_POLICY			0x10
+#define AR9331_MBOX_DMA_RX_DESCRIPTOR_BASE	0x18
+#define AR9331_MBOX_DMA_RX_CONTROL		0x1c
+#define AR9331_MBOX_DMA_TX_DESCRIPTOR_BASE	0x20
+#define AR9331_MBOX_DMA_TX_CONTROL		0x24
+#define AR9331_MBOX_INT_STATUS			0x44
+#define AR9331_MBOX_INT_ENABLE			0x4c
+#define AR9331_MBOX_DMA_FIFO_RESET		0x58
+#define AR9331_SLIC_MBOX_DMA_FIFO_RESET		0x5C
+
+#define AR9331_MBOX_DMA_CONTROL_STOP			BIT(0)
+#define AR9331_MBOX_DMA_CONTROL_START			BIT(1)
+#define AR9331_MBOX_DMA_CONTROL_RESUME			BIT(2)
+
+#define AR9331_MBOX_DMA_POLICY_RX_QUANTUM		BIT(1)
+#define AR9331_MBOX_DMA_POLICY_TX_QUANTUM		BIT(3)
+#define AR9331_MBOX_DMA_POLICY_TX_FIFO_THRESH(v)	(((v) & 0xf) << 4)
+
+#define AR9331_MBOX_DMA_FIFO_RESET_TX_INIT		BIT(2)
+#define AR9331_MBOX_DMA_FIFO_RESET_RX_INIT		BIT(0)
+
+#define AR9331_MBOX_INT_ENABLE_RX_DMA_COMPLETE		BIT(10)
+#define AR9331_MBOX_INT_ENABLE_TX_DMA_EOM_COMPLETE	BIT(8)
+#define AR9331_MBOX_INT_ENABLE_TX_DMA_COMPLETE		BIT(6)
+#define AR9331_MBOX_INT_ENABLE_TX_OVERFLOW		BIT(5)
+#define AR9331_MBOX_INT_ENABLE_RX_UNDERFLOW		BIT(4)
+#define AR9331_MBOX_INT_ENABLE_TX_NOT_EMPTY		BIT(2)
+#define AR9331_MBOX_INT_ENABLE_RX_NOT_FULL		BIT(0)
+
+/* Reset Registers */
+#define AR9331_RESET_RST_RESET				0x00
+
+#define AR9331_RESET_RST_RESET_MBOX			BIT(1)
+#define AR9331_RESET_RST_RESET_I2S			BIT(0)
+
+
+
+#define ATH79_MISC_IRQ_BASE	8
+#define ATH79_MISC_IRQ(_x)	(ATH79_MISC_IRQ_BASE + (_x))
+
+extern spinlock_t ar71xx_pcm_lock;
+
+struct ar71xx_pcm_desc {
+	unsigned int	OWN	:  1,    /* bit 31 */
+			EOM	:  1,    /* bit 30 */
+			rsvd1	:  6,    /* bit 29-24 */
+			size	: 12,    /* bit 23-12 */
+			length	: 12,    /* bit 11-00 */
+			rsvd2	:  4,    /* bit 31-28 */
+			BufPtr	: 28,    /* bit 27-00 */
+			rsvd3	:  4,    /* bit 31-28 */
+			NextPtr	: 28;    /* bit 27-00 */
+
+	unsigned int Va[6];
+	unsigned int Ua[6];
+	unsigned int Ca[6];
+	unsigned int Vb[6];
+	unsigned int Ub[6];
+	unsigned int Cb[6];
+
+	/* Software specific data
+	 * These data are not taken into account by the HW */
+	struct list_head list; /* List linking all the buffer in virt@ space */
+	dma_addr_t phys; /* Physical address of the descriptor */
+};
+
+struct ar71xx_pcm_rt_priv {
+	struct list_head dma_head;
+	struct ar71xx_pcm_desc *last_played;
+	unsigned int elapsed_size;
+	unsigned int delay_time;
+	int direction;
+};
+
+/* Replaces struct ath_i2s_softc */
+struct ar71xx_pcm_pltfm_priv {
+	struct snd_pcm_substream *playback;
+	struct snd_pcm_substream *capture;
+
+	struct device		*dev;
+
+	struct regmap 		*mbox_regmap;
+	struct regmap		*reset_regmap;
+	struct regmap		*misc_int_regmap;
+
+	bool irq_en;
+};
+
+
+
+/* platform data */
+extern struct snd_soc_platform_driver ar71xx_soc_platform;
+
+/* mbox functions */
+void ar71xx_mbox_interrupt_ack(u32 mask, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_start(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_stop(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_prepare(struct ar71xx_pcm_rt_priv *rtpriv, struct ar71xx_pcm_pltfm_priv *dev);
+int ar71xx_mbox_dma_map(struct ar71xx_pcm_rt_priv *rtpriv, dma_addr_t baseaddr,
+			int period_bytes, int bufsize);
+void ar71xx_mbox_dma_unmap(struct ar71xx_pcm_rt_priv *rtpriv);
+int ar71xx_mbox_dma_init(struct device *dev);
+void ar71xx_mbox_dma_exit(void);
+void ar71xx_mbox_dma_reset(struct ar71xx_pcm_pltfm_priv *dev);
+void ar71xx_mbox_dma_rx_resume(struct ar71xx_pcm_pltfm_priv *dev);
+
+
+/* sets OWN bits in descriptor to 1 and returns overall size of played data */
+static inline unsigned int ar71xx_pcm_set_own_bits(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc;
+	unsigned int size_played = 0;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 0) {
+			desc->OWN = 1;
+			size_played += desc->size;
+		}
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+	return size_played;
+}
+
+static inline void ar71xx_pcm_clear_own_bits(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc;
+
+	spin_lock(&ar71xx_pcm_lock);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 1) {
+			desc->OWN = 0;
+		}
+	}
+	spin_unlock(&ar71xx_pcm_lock);
+}
+
+static inline struct ar71xx_pcm_desc *ar71xx_pcm_get_last_played(struct ar71xx_pcm_rt_priv *rtpriv)
+{
+	struct ar71xx_pcm_desc *desc, *prev;
+
+
+	spin_lock(&ar71xx_pcm_lock);
+	prev = list_entry(rtpriv->dma_head.prev, struct ar71xx_pcm_desc, list);
+	list_for_each_entry(desc, &rtpriv->dma_head, list) {
+		if (desc->OWN == 1 && prev->OWN == 0) {
+			return desc;
+		}
+		prev = desc;
+	}
+
+	spin_unlock(&ar71xx_pcm_lock);
+
+	/* If we didn't find the last played buffer, return NULL */
+	return NULL;
+}
+
+
+#endif /* AR71XX_PCM_H */
--- /dev/null
+++ b/arch/mips/ath79/dev-pcm.c
@@ -0,0 +1,23 @@
+/*
+ *  Atheros AR9331 PCM Audio support
+ *
+ *  Copyright (C) 2014-2015 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include "dev-pcm.h"
+
+int __init ath79_register_pcm(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		pr_debug("Unable to register platform device '%s' %d\n",
+		         pdev->name, ret);
+
+	return ret;
+}
--- /dev/null
+++ b/arch/mips/ath79/dev-pcm.h
@@ -0,0 +1,21 @@
+/*
+ *  Atheros AR9331 PCM Audio support
+ *
+ *  Copyright (C) 2014-2015 Felix Kramer <felixkramerroki@aol.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#ifndef _ATH79_DEV_PCM_H
+#define _ATH79_DEV_PCM_H
+
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+
+int __init ath79_register_pcm(struct platform_device *pdev);
+
+
+#endif /* _ATH79_DEV_PCM_H */
--- /dev/null
+++ b/sound/soc/ar71xx/tas5711_ev-board.c
@@ -0,0 +1,103 @@
+/* 
+ * ASoC Driver for TI TAS5711 Evaluation Board
+ *
+ * Author: Felix Kramer <felixkramerroki@aol.com>
+ * based on the HifiBerry DAC driver by Florian Meier <florian.meier@koalo.de>
+ *		Copyright 2014
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+
+static int snd_carambola2_tas5711_evb_init(struct snd_soc_pcm_runtime *rtd)
+{
+	printk("+++++++++++initialized tas5711 evaluation board driver++++++++++++\n");
+	return 0;
+}
+
+static int snd_carambola2_tas5711_evb_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	unsigned int sample_bits =
+		snd_pcm_format_physical_width(params_format(params));
+
+	return snd_soc_dai_set_bclk_ratio(cpu_dai, sample_bits * 2);
+}
+
+/* machine stream operations */
+static struct snd_soc_ops snd_carambola2_tas5711_evb_ops = {
+	.hw_params = snd_carambola2_tas5711_evb_hw_params,
+};
+
+static struct snd_soc_dai_link snd_carambola2_tas5711_evb_dai[] = {
+{
+	.name		= "TAS5711 EVB",
+	.stream_name	= "TI TAS5711 Evaluation Board",
+	.cpu_dai_name	= "ar71xx-i2s.0",
+	.codec_dai_name	= "tas5711-hifi", 
+	.platform_name	= "ar71xx-pcm.0",
+	.codec_name	= "tas5711.1-001b",
+	.dai_fmt	= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				SND_SOC_DAIFMT_CBS_CFS,
+	.ops		= &snd_carambola2_tas5711_evb_ops,
+	.init		= snd_carambola2_tas5711_evb_init,
+},
+};
+
+/* audio machine driver */
+static struct snd_soc_card snd_carambola2_tas5711_evb = {
+	.name         = "snd_carambola2_tas5711_evb",
+	.dai_link     = snd_carambola2_tas5711_evb_dai,
+	.num_links    = ARRAY_SIZE(snd_carambola2_tas5711_evb_dai),
+};
+
+static int snd_carambola2_tas5711_evb_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	snd_carambola2_tas5711_evb.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_carambola2_tas5711_evb);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int snd_carambola2_tas5711_evb_remove(struct platform_device *pdev)
+{
+	return snd_soc_unregister_card(&snd_carambola2_tas5711_evb);
+}
+
+static struct platform_driver snd_carambola2_tas5711_evb_driver = {
+        .driver = {
+                .name   = "snd-tas5711-evb",
+                .owner  = THIS_MODULE,
+        },
+        .probe          = snd_carambola2_tas5711_evb_probe,
+        .remove         = snd_carambola2_tas5711_evb_remove,
+};
+
+module_platform_driver(snd_carambola2_tas5711_evb_driver);
+
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_DESCRIPTION("ASoC Driver for TAS5711 Evaluation Board");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/tas5711.c
@@ -0,0 +1,1012 @@
+/*
+ * TAS5711 ASoC codec driver
+ *
+ * Author: Felix Kramer <felixkramerroki@aol.com>
+ * based on the TAS5086 ASoC codec driver by Daniel Mack <zonque@gmail.com>
+ *		Copyright 2014
+ *
+ *	TODO:
+ *		check really needed librarys 
+ *		tas5711_register_size size 8 size 12??
+ *		control parameters of TLV macros (line 512)
+ *		DAPM Parameters
+ *		CONFIG_OF, CONFIG_PM??
+ *		"ti,start-stop-period" ????
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+//TODO check really needed librarys 
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+//#include <linux/spi/spi.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define TAS5711_CLK_IDX_MCLK	0
+#define TAS5711_CLK_IDX_SCLK	1
+
+/*
+ * TAS5711 registers
+ */
+
+#if 0 // TAS5711 has automatic clock detect so we don't have to write in these registers
+#define TAS5711_CLOCK_RATE(val)		(val << 5)
+#define TAS5711_CLOCK_RATE_MASK		(0x7 << 5)
+#define TAS5711_CLOCK_RATIO(val)	(val << 2)
+#define TAS5711_CLOCK_RATIO_MASK	(0x7 << 2)
+#endif
+
+#define TAS5711_OSC_TRIM_VAL(val) 	(val << 1)
+#define TAS5711_OSC_TRIM_VAL_MASK	(0x1 << 1)
+
+#define TAS5711_CLOCK_CONTROL		0x00			/* Clock control register  */
+#define TAS5711_DEV_ID			0x01			/* Device ID register */
+#define TAS5711_ERROR_STATUS		0x02			/* Error status register */
+#define TAS5711_SYS_CONTROL_1		0x03			/* System control register 1 */
+#define TAS5711_SERIAL_DATA_IF		0x04			/* Serial data interface register  */
+#define TAS5711_SYS_CONTROL_2		0x05			/* System control register 2 */
+#define TAS5711_SOFT_MUTE		0x06			/* Soft mute register */
+#define TAS5711_MASTER_VOL		0x07			/* Master volume  */
+#define TAS5711_CHANNEL_VOL(X)		(0x08 + (X))	/* Channel 1-3 volume */
+#define TAS5711_VOLUME_CONFIG		0x0E			/* Volume configuration register */
+#define TAS5711_MOD_LIMIT		0x10			/* Modulation limit register */
+#define TAS5711_INTER_DLY_1		0x11			/* Interchannel Delay Registers, Channel 1 */
+#define TAS5711_INTER_DLY_2		0x12			/* Channel 2 */
+#define TAS5711_INTER_DLY_not1		0x13			/* Channel not 1 */
+#define TAS5711_INTER_DLY_not2		0x14			/* Channel not 2 */
+#define TAS5711_PWM_SHUTDOWN		0x19			/* PWM shutdown group register */
+#define TAS5711_START_STOP_PERIOD	0x1A			/* Start/Stop period register */
+#define TAS5711_OSC_TRIM		0x1B			/* Oscillator trim register */
+#define TAS5711_BKNDERR 		0x1C			/* Back-end error register */
+
+#define TAS5711_INPUT_MUX		0x20			/* Input multiplexer register */
+#define TAS5711_CHNL_4_SRC_SELECT	0x21			/* Channel 4 source select register */
+#define TAS5711_PWM_OUTPUT_MUX		0x25			/* PWM output mux register */
+#define TAS5711_DRC_CONTROL		0x46			/* DRC control register */
+#define TAS5711_BANK_SWITCH_EQ		0x50			/* Bank switch and eq control register */
+
+
+#define TAS5711_MAX_REGISTER		TAS5711_BANK_SWITCH_EQ
+
+/* Bit Masks */
+#define TAS5711_DEEMPH_MASK		0x03
+#define TAS5711_SOFT_MUTE_ALL		0x07
+
+/* Format Parameters */
+#define TAS5711_PCM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  |		\
+			     SNDRV_PCM_FMTBIT_S20_3LE |		\
+			     SNDRV_PCM_FMTBIT_S24_LE |		\
+			     SNDRV_PCM_FMTBIT_S32_LE)
+#if 0
+/*
+ *	make list with snc_pcm_constraint_list()
+ */
+
+#define TAS5711_PCM_RATES   (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025  | \
+			     SNDRV_PCM_RATE_12000 | SNDRV_PCM_RATE_16000  | \
+			     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_24000 | \
+			     SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+#endif				 
+#define TAS5711_PCM_RATES   (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025  | \
+			     SNDRV_PCM_RATE_16000 | \
+			     SNDRV_PCM_RATE_22050 | \
+			     SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+/*
+ * Default TAS5711 power-up configuration
+ */
+
+static const struct reg_default tas5711_reg_defaults[] = {
+	{ 0x00,	0x6c },
+	{ 0x01,	0x70 },
+	{ 0x02,	0x00 },
+	{ 0x03,	0xA0 },
+	{ 0x04,	0x05 },
+	{ 0x05,	0x40 },
+	{ 0x06,	0x00 },
+	{ 0x07,	0xFF },
+	{ 0x08,	0x30 },
+	{ 0x09,	0x30 },
+	{ 0x0a,	0x30 },
+	{ 0x0e,	0x91 },
+	{ 0x10,	0x02 },
+	{ 0x11,	0xAC },
+	{ 0x12,	0x54 },
+	{ 0x13,	0xAC },
+	{ 0x14,	0x54 },
+	{ 0x19,	0x30 },
+	{ 0x1A,	0x0F },
+	{ 0x1B,	0x82 },
+	{ 0x1C,	0x02 },
+	{ 0x20,	0x00017772 },
+	{ 0x21,	0x00004303 },
+	{ 0x25,	0x01021345 },
+	{ 0x46,	0x00000000 },
+	{ 0x50,	0x0F708000 },
+};
+
+static int tas5711_register_size(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+		case TAS5711_CLOCK_CONTROL ... TAS5711_CHANNEL_VOL(3):
+		case TAS5711_VOLUME_CONFIG:
+		case TAS5711_MOD_LIMIT ... TAS5711_BKNDERR:
+			return 1;
+		case TAS5711_INPUT_MUX ... TAS5711_CHNL_4_SRC_SELECT:
+		case TAS5711_PWM_OUTPUT_MUX:
+		case TAS5711_DRC_CONTROL:
+		case TAS5711_BANK_SWITCH_EQ:
+			return 4;
+	}
+
+	dev_err(dev, "Unsupported register address: %d\n", reg);
+	return 0;
+}
+
+static bool tas5711_accessible_reg(struct device *dev, unsigned int reg)
+{
+	/* reserved register returns false */
+	switch (reg) {
+		case 0x0B ... 0x0D:
+		case 0x0F:
+		case 0x15 ... 0x18:
+		case 0x1D ... 0x1F:
+		case 0x22 ... 0x24:
+		case 0x26 ... 0x28:
+		case 0x37 ... 0x39:
+		case 0x47 ... 0x4F:
+		case 0x5F:
+		case 0x63 ... 0xF7:
+		case 0xFB ... 0xFF:
+			return false;
+		default:
+			return true;
+	}
+}
+
+static bool tas5711_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/* any more?? */
+	switch (reg) {
+		case TAS5711_CLOCK_CONTROL:
+		case TAS5711_DEV_ID:
+		case TAS5711_ERROR_STATUS:
+			return true;
+	}
+	return false;
+}
+
+static bool tas5711_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return tas5711_accessible_reg(dev, reg) && (reg != TAS5711_DEV_ID);
+}
+
+static int tas5711_reg_write(void *context, unsigned int reg,
+			      unsigned int value)
+{
+	struct i2c_client *client = context;
+	unsigned int i, size;
+	uint8_t buf[5];
+	int ret;
+
+	size = tas5711_register_size(&client->dev, reg);
+	if (size == 0)
+		return -EINVAL;
+
+	buf[0] = reg;
+
+	for (i = size; i >= 1; --i) {
+		buf[i] = value;
+		value >>= 8;
+	}
+
+	ret = i2c_master_send(client, buf, size + 1);
+	if (ret == size + 1)
+		return 0;
+	else if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+
+static int tas5711_reg_read(void *context, unsigned int reg,
+			     unsigned int *value)
+{
+	/* write value of register "reg" to "value" */
+	struct i2c_client *client = context;
+	uint8_t send_buf, recv_buf[4];
+	struct i2c_msg msgs[2];
+	unsigned int size;
+	unsigned int i;
+	int ret;
+
+	size = tas5711_register_size(&client->dev, reg);
+	if (size == 0)
+		return -EINVAL;
+
+	send_buf = reg;
+
+	msgs[0].addr = client->addr;
+	msgs[0].len = sizeof(send_buf);
+	msgs[0].buf = &send_buf;
+	msgs[0].flags = 0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].len = size;
+	msgs[1].buf = recv_buf;
+	msgs[1].flags = I2C_M_RD;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0)
+		return ret;
+	else if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*value = 0;
+
+	for (i = 0; i < size; i++) {
+		*value <<= 8;
+		*value |= recv_buf[i];
+	}
+
+	return 0;
+}
+
+struct tas5711_private {
+	struct regmap	*regmap;
+	unsigned int	mclk, sclk;
+	unsigned int	format;
+
+	bool		deemph;
+
+	/* Current sample rate for de-emphasis control */
+	int		rate;
+	/* GPIO driving Reset pin, if any */
+	int		gpio_nreset;
+};
+
+static int tas5711_deemph[] = { 0, 32000, 44100, 48000 };
+
+static int tas5711_set_deemph(struct snd_soc_codec *codec)
+{
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+	int i, val = 0;
+
+	if (priv->deemph)
+		for (i = 0; i < ARRAY_SIZE(tas5711_deemph); i++)
+			if (tas5711_deemph[i] == priv->rate)
+				val = i;
+
+	return regmap_update_bits(priv->regmap, TAS5711_SYS_CONTROL_1,
+				  TAS5711_DEEMPH_MASK, val);
+}
+
+static int tas5711_get_deemph(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+
+	ucontrol->value.enumerated.item[0] = priv->deemph;
+
+	return 0;
+}
+
+static int tas5711_put_deemph(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+
+	priv->deemph = ucontrol->value.enumerated.item[0];
+
+	return tas5711_set_deemph(codec);
+}
+
+
+
+static int tas5711_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+
+	switch (clk_id) {
+		case TAS5711_CLK_IDX_MCLK:
+			priv->mclk = freq;
+			break;
+		case TAS5711_CLK_IDX_SCLK:
+			priv->sclk = freq;
+			break;
+	}
+
+	return 0;
+}
+
+static int tas5711_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int format)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+
+	/* The TAS5086 can only be slave to all clocks */
+	/* same with TA5711 ?? */
+	if ((format & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {
+		dev_err(codec->dev, "Invalid clocking mode\n");
+		return -EINVAL;
+	}
+
+	/* we need to refer to the data format from hw_params() */
+	priv->format = format;
+
+	return 0;
+}
+
+#if 0 // not needed because of clock auto detect
+static const int tas5711_sample_rates[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000
+};
+
+
+
+static const int tas5711_ratios[] = {
+	64, 128, 192, 256, 384, 512
+};
+#endif
+
+
+static int index_in_array(const int *array, int len, int needle)
+{
+	/* returns index of value "needle" in given array */
+	int i;
+
+	for (i = 0; i < len; i++)
+		if (array[i] == needle)
+			return i;
+
+	return -ENOENT;
+}
+
+static int tas5711_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	/* set hardware parameters 
+	 * propably when starting the driver 
+	 */
+	struct snd_soc_codec *codec = dai->codec;
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+	int val;
+	int ret;
+
+	priv->rate = params_rate(params);
+	
+#if 0 //TAS5711 has clock auto detect so the following shouldn't be needed
+
+	/* Look up the sample rate and refer to the offset in the list */
+	val = index_in_array(tas5711_sample_rates,
+			     ARRAY_SIZE(tas5711_sample_rates), priv->rate);
+
+	if (val < 0) {
+		dev_err(codec->dev, "Invalid sample rate\n");
+		return -EINVAL;
+	}
+	
+
+	ret = regmap_update_bits(priv->regmap, TAS5711_CLOCK_CONTROL,
+				 TAS5711_CLOCK_RATE_MASK,
+				 TAS5711_CLOCK_RATE(val));
+	if (ret < 0)
+		return ret;
+
+
+	/* MCLK / Fs ratio */
+	val = index_in_array(tas5711_ratios, ARRAY_SIZE(tas5086_ratios),
+			     priv->mclk / priv->rate);
+	if (val < 0) {
+		dev_err(codec->dev, "Inavlid MCLK / Fs ratio\n");
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,
+				 TAS5086_CLOCK_RATIO_MASK,
+				 TAS5086_CLOCK_RATIO(val));
+	if (ret < 0)
+		return ret;
+
+
+	ret = regmap_update_bits(priv->regmap, TAS5711_CLOCK_CONTROL,
+				 TAS5711_CLOCK_SCLK_RATIO_48,
+				 (priv->sclk == 48 * priv->rate) ? 
+					TAS5711_CLOCK_SCLK_RATIO_48 : 0);
+	if (ret < 0)
+		return ret;
+		
+#endif
+
+
+	/*
+	 * Same format mapping as the TAS5086
+	 *
+	 * Commend from Daniel Mack:
+	 * The chip has a very unituitive register mapping and muxes information
+	 * about data format and sample depth into the same register, but not on
+	 * a logical bit-boundary. Hence, we have to refer to the format passed
+	 * in the set_dai_fmt() callback and set up everything from here.
+	 *
+	 * First, determine the 'base' value, using the format ...
+	 */
+// XXX we use the default format for now
+#if 0 
+	switch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_RIGHT_J:
+			val = 0x00;
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			val = 0x03;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			val = 0x06;
+			break;
+		default:
+			dev_err(codec->dev, "Invalid DAI format\n");
+			return -EINVAL;
+	}
+
+	/* ... then add the offset for the sample bit depth. */
+	switch (params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+			val += 0;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			val += 1;
+			break;
+		case SNDRV_PCM_FORMAT_S24_3LE:
+			val += 2;
+			break;
+		default:
+			dev_err(codec->dev, "Invalid bit width\n");
+			return -EINVAL;
+	};
+
+	ret = regmap_write(priv->regmap, TAS5711_SERIAL_DATA_IF, val);
+	if (ret < 0)
+		return ret;
+#endif
+#if 0
+	/* clock is considered valid now */
+	ret = regmap_update_bits(priv->regmap, TAS5711_CLOCK_CONTROL,
+				 TAS5711_CLOCK_VALID, TAS5711_CLOCK_VALID);
+	if (ret < 0)
+		return ret;
+#endif
+
+	return tas5711_set_deemph(codec);
+	/*
+	 * which returns:
+	 *		regmap_update_bits(priv->regmap, TAS5711_SYS_CONTROL_1,
+	 *			  TAS5711_DEEMPH_MASK, val);
+	 */
+}
+
+static int tas5711_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+	unsigned int val = 0;
+
+	if (mute)
+		val = TAS5711_SOFT_MUTE_ALL;
+
+	return regmap_write(priv->regmap, TAS5711_SOFT_MUTE, val);
+}
+
+
+ 
+/* TAS5711 controls */
+static const DECLARE_TLV_DB_SCALE(tas5711_dac_tlv, -10350, 50, 1);
+
+
+static const struct snd_kcontrol_new tas5711_controls[] = {
+	SOC_SINGLE_TLV("Master Playback Volume", TAS5711_MASTER_VOL,
+		       0, 0xff, 1, tas5711_dac_tlv),
+	SOC_SINGLE_TLV("Channel 1 Volume", TAS5711_CHANNEL_VOL(0),
+		       0, 0xff, 1, tas5711_dac_tlv),
+	SOC_SINGLE_TLV("Channel 2 Volume", TAS5711_CHANNEL_VOL(1),
+		       0, 0xff, 1, tas5711_dac_tlv),
+#if 0
+	SOC_DOUBLE_R_TLV("Channel 1/2 Playback Volume",
+			 TAS5711_CHANNEL_VOL(0), TAS5711_CHANNEL_VOL(1),
+			 0, 0xff, 1, tas5711_dac_tlv),
+	SOC_SINGLE_TLV("Channel 3 Playback Volume",
+			 TAS5711_CHANNEL_VOL(2),
+			 0, 0xff, 1, tas5711_dac_tlv),
+	SOC_SINGLE_BOOL_EXT("De-emphasis Switch", 0,
+			    tas5711_get_deemph, tas5711_put_deemph),
+#endif
+};
+
+// not really needed
+#if 0
+/* Input mux controls */
+static const char *tas5711_dapm_sdin_texts[] =
+{
+	"SDIN-L", "SDIN-R"
+};
+
+//TODO check this, SOC_ENUM_SINGLE()???
+static const struct soc_enum tas5711_dapm_input_mux_enum[] = {
+	SOC_ENUM_SINGLE(TAS5711_INPUT_MUX, 20, 8, tas5711_dapm_sdin_texts),
+	SOC_ENUM_SINGLE(TAS5711_INPUT_MUX, 16, 8, tas5711_dapm_sdin_texts),
+};
+
+static const struct snd_kcontrol_new tas5711_dapm_input_mux_controls[] = {
+	SOC_DAPM_ENUM("Channel 1 input", tas5711_dapm_input_mux_enum[0]),
+	SOC_DAPM_ENUM("Channel 2 input", tas5711_dapm_input_mux_enum[1]),
+};
+
+/* Output mux controls */
+static const char *tas5711_dapm_channel_texts[] =
+	{ "Channel 1 Mux", "Channel 2 Mux", 
+	  "Channel 3 Mux", "Channel 4 Mux"};
+
+static const struct soc_enum tas5711_dapm_output_mux_enum[] = {
+	SOC_ENUM_SINGLE(TAS5711_PWM_OUTPUT_MUX, 20, 6, tas5711_dapm_channel_texts),
+	SOC_ENUM_SINGLE(TAS5711_PWM_OUTPUT_MUX, 16, 6, tas5711_dapm_channel_texts),
+	SOC_ENUM_SINGLE(TAS5711_PWM_OUTPUT_MUX, 12, 6, tas5711_dapm_channel_texts),
+	SOC_ENUM_SINGLE(TAS5711_PWM_OUTPUT_MUX, 8,  6, tas5711_dapm_channel_texts),
+};
+
+static const struct snd_kcontrol_new tas5711_dapm_output_mux_controls[] = {
+	SOC_DAPM_ENUM("OUT_A", tas5711_dapm_output_mux_enum[0]),
+	SOC_DAPM_ENUM("OUT_B", tas5711_dapm_output_mux_enum[1]),
+	SOC_DAPM_ENUM("OUT_C", tas5711_dapm_output_mux_enum[2]),
+	SOC_DAPM_ENUM("OUT_D", tas5711_dapm_output_mux_enum[3]),
+};
+
+static const struct snd_soc_dapm_widget tas5711_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("SDIN-L"), //TODO this should be "Channel 1 input"
+	SND_SOC_DAPM_INPUT("SDIN-R"),
+
+	SND_SOC_DAPM_OUTPUT("OUT_A"), // or this should be "Channel 1 Mux"
+	SND_SOC_DAPM_OUTPUT("OUT_B"),
+	SND_SOC_DAPM_OUTPUT("OUT_C"),
+	SND_SOC_DAPM_OUTPUT("OUT_D"),
+
+
+	SND_SOC_DAPM_MUX("Channel 1 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_input_mux_controls[0]),
+	SND_SOC_DAPM_MUX("Channel 2 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_input_mux_controls[1]),
+	SND_SOC_DAPM_MUX("Channel 3 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_input_mux_controls[2]),
+	SND_SOC_DAPM_MUX("Channel 4 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_input_mux_controls[3]),
+
+	SND_SOC_DAPM_MUX("PWM1 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_output_mux_controls[0]),
+	SND_SOC_DAPM_MUX("PWM2 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_output_mux_controls[1]),
+	SND_SOC_DAPM_MUX("PWM3 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_output_mux_controls[2]),
+	SND_SOC_DAPM_MUX("PWM4 Mux", SND_SOC_NOPM, 0, 0,
+			 &tas5711_dapm_output_mux_controls[3]),
+};
+
+static const struct snd_soc_dapm_route tas5711_dapm_routes[] = {
+	/* SDIN inputs -> channel muxes */
+	{ "Channel 1 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 1 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 2 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 2 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 2 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 2 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 3 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 3 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 4 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 4 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 5 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 5 Mux", "SDIN-R", "SDIN-R" },
+
+	{ "Channel 6 Mux", "SDIN-L", "SDIN-L" },
+	{ "Channel 6 Mux", "SDIN-R", "SDIN-R" },
+
+	/* Channel muxes -> PWM muxes */
+	{ "PWM1 Mux", "Channel 1 Mux", "Channel 1 Mux" },
+	{ "PWM2 Mux", "Channel 1 Mux", "Channel 1 Mux" },
+	{ "PWM3 Mux", "Channel 1 Mux", "Channel 1 Mux" },
+	{ "PWM4 Mux", "Channel 1 Mux", "Channel 1 Mux" },
+
+	{ "PWM1 Mux", "Channel 2 Mux", "Channel 2 Mux" },
+	{ "PWM2 Mux", "Channel 2 Mux", "Channel 2 Mux" },
+	{ "PWM3 Mux", "Channel 2 Mux", "Channel 2 Mux" },
+	{ "PWM4 Mux", "Channel 2 Mux", "Channel 2 Mux" },
+
+	{ "PWM1 Mux", "Channel 3 Mux", "Channel 3 Mux" },
+	{ "PWM2 Mux", "Channel 3 Mux", "Channel 3 Mux" },
+	{ "PWM3 Mux", "Channel 3 Mux", "Channel 3 Mux" },
+	{ "PWM4 Mux", "Channel 3 Mux", "Channel 3 Mux" },
+
+	{ "PWM1 Mux", "Channel 4 Mux", "Channel 4 Mux" },
+	{ "PWM2 Mux", "Channel 4 Mux", "Channel 4 Mux" },
+	{ "PWM3 Mux", "Channel 4 Mux", "Channel 4 Mux" },
+	{ "PWM4 Mux", "Channel 4 Mux", "Channel 4 Mux" },
+
+	{ "PWM1 Mux", "Channel 5 Mux", "Channel 5 Mux" },
+	{ "PWM2 Mux", "Channel 5 Mux", "Channel 5 Mux" },
+	{ "PWM3 Mux", "Channel 5 Mux", "Channel 5 Mux" },
+	{ "PWM4 Mux", "Channel 5 Mux", "Channel 5 Mux" },
+
+	{ "PWM1 Mux", "Channel 6 Mux", "Channel 6 Mux" },
+	{ "PWM2 Mux", "Channel 6 Mux", "Channel 6 Mux" },
+	{ "PWM3 Mux", "Channel 6 Mux", "Channel 6 Mux" },
+	{ "PWM4 Mux", "Channel 6 Mux", "Channel 6 Mux" },
+
+};
+
+#endif
+static const struct snd_soc_dai_ops tas5711_dai_ops = {
+	.hw_params	= tas5711_hw_params,
+	.set_sysclk	= tas5711_set_dai_sysclk,
+	.set_fmt	= tas5711_set_dai_fmt,
+	.mute_stream	= tas5711_mute_stream,
+};
+
+static struct snd_soc_dai_driver tas5711_dai = {
+	.name = "tas5711-hifi",
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 2,
+		.channels_max	= 3,
+		.rates		= TAS5711_PCM_RATES,
+		.formats	= TAS5711_PCM_FORMATS,
+	},
+	.ops = &tas5711_dai_ops,
+};
+
+#ifdef CONFIG_PM
+static int tas5711_soc_resume(struct snd_soc_codec *codec)
+{
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+
+	/* Restore codec state */
+	return regcache_sync(priv->regmap);
+}
+#else
+#define tas5711_soc_resume	NULL
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id tas5711_dt_ids[] = {
+	{ .compatible = "ti,tas5711", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tas5711_dt_ids);
+#endif
+
+
+/* start/stop period values in microseconds */
+static const int tas5711_start_stop_period[] = {
+	  16500,   23900,   31400,   40400,   53900,   70300,   94200,   125700,
+	 164600,  239400,  314200,  403900,  538600,  703100,  942500,  1256600,
+	1728100, 2513600, 3299100, 4241700, 5655600, 7383700, 9897300, 13196400,
+};
+
+static int tas5711_probe(struct snd_soc_codec *codec)
+{
+	printk("++++++++++++++++++int tas5711 probe()++++++++++++++++++++\n");
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+	int start_stop_period = 125700; /* hardware default is 125,70 ms */
+	u8 pwm_start_mid_z = 0;
+	int i, ret;
+
+	//TODO what does this???
+	if (of_match_device(of_match_ptr(tas5711_dt_ids), codec->dev)) {
+		struct device_node *of_node = codec->dev->of_node;
+		//TODO "ti,start-stop-period" ????
+		of_property_read_u32(of_node, "ti,start-stop-period", &start_stop_period);
+
+#if 0
+		for (i = 0; i < 6; i++) {
+			char name[25];
+
+			snprintf(name, sizeof(name),
+				 "ti,mid-z-channel-%d", i + 1);
+
+			if (of_get_property(of_node, name, NULL) != NULL)
+				pwm_start_mid_z |= 1 << i;
+		}
+		
+#endif
+	}
+	else
+		printk("of_match_device() == false\n");
+#if 0
+	/*
+	 * If any of the channels is configured to start in Mid-Z mode,
+	 * configure 'part 1' of the PWM starts to use Mid-Z, and tell
+	 * all configured mid-z channels to start start under 'part 1'.
+	 */
+	if (pwm_start_mid_z)
+		regmap_write(priv->regmap, TAS5711_PWM_START,
+			     TAS5711_PWM_START_MIDZ_FOR_START_1 |
+				pwm_start_mid_z);
+
+	/* lookup and set split-capacitor charge period */
+	if (charge_period == 0) {
+		regmap_write(priv->regmap, TAS5711_SPLIT_CAP_CHARGE, 0);
+	} else {
+		i = index_in_array(tas5711_charge_period,
+				   ARRAY_SIZE(tas5711_charge_period),
+				   charge_period);
+		if (i >= 0)
+			regmap_write(priv->regmap, TAS5711_SPLIT_CAP_CHARGE,
+				     i + 0x08);
+		else
+			dev_warn(codec->dev,
+				 "Invalid split-cap charge period of %d ns.\n",
+				 charge_period);
+	}
+#endif
+
+//XXX writing to reserved registers. this is ok said the datasheet
+#if 1
+	/* enable Oscillator trim */
+	ret = regmap_write(priv->regmap, TAS5711_OSC_TRIM,
+			   0x00);
+	if (ret < 0) {
+		printk("setting up oscillator trim failed\n");
+		return ret;
+	}
+#else
+	/* enable factory trim */
+	ret = regmap_update_bits(priv->regmap, TAS5711_OSC_TRIM, 
+						TAS5711_OSC_TRIM_VAL(0), 
+						TAS5711_OSC_TRIM_VAL_MASK);
+	if (ret < 0) {
+		printk("oscillator trim failed\n");
+		return ret;
+	}
+#endif
+// TODO check what to do here
+#if 0 
+	/* start all channels */
+	ret = regmap_write(priv->regmap, TAS5711_SYS_CONTROL_2, 0x20);
+	if (ret < 0)
+		return ret;
+
+	/* set master volume to 0 dB */
+	ret = regmap_write(priv->regmap, TAS5711_MASTER_VOL, 0x30);
+	if (ret < 0)
+		return ret;
+#endif
+	/* start all channel (disable hard mute) */
+	ret = regmap_write(priv->regmap, TAS5711_SYS_CONTROL_2,
+			   0x00);
+	if (ret < 0) {
+		printk("starting all channels failed\n");
+		return ret;
+	}
+
+
+	/* unmute all channels for now */
+	ret = regmap_write(priv->regmap, TAS5711_SOFT_MUTE,
+			   /*TAS5711_SOFT_MUTE_ALL*/0x00);
+	if (ret < 0) {
+		printk("soft mute on all channels failed\n");
+		return ret;
+	}
+
+	/* set error status register to zero */
+	ret = regmap_write(priv->regmap, TAS5711_ERROR_STATUS,
+			   0x00);
+	if (ret < 0) {
+		printk("resetting error status register failed\n");
+		return ret;
+	}
+
+	/* set master volume to 0 dB */
+	ret = regmap_write(priv->regmap, TAS5711_MASTER_VOL,
+			   0x30);
+	if (ret < 0) {
+		printk("setting master volume to 0dB failed\n");
+		return ret;
+	}
+
+
+	return 0;
+}
+
+static int tas5711_remove(struct snd_soc_codec *codec)
+{
+	struct tas5711_private *priv = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	/* mute all channels */
+	ret = regmap_write(priv->regmap, TAS5711_SOFT_MUTE,
+			   TAS5711_SOFT_MUTE_ALL);
+	if (ret < 0) {
+		printk("soft mute all channels failed\n");
+		return ret;
+	}
+
+	/* start all channel (disable hard mute) */
+	// TODO use macros here!
+	ret = regmap_update_bits(priv->regmap, TAS5711_SYS_CONTROL_2, 
+						0x40, 
+						0x40);
+	if (ret < 0) {
+		printk("stop all channels failed\n");
+		return ret;
+	}
+#if 0
+	ret = regmap_write(priv->regmap, TAS5711_SYS_CONTROL_2,
+			   0x0);
+	if (ret < 0) {
+		printk("stop all channels failed\n");
+		return ret;
+	}
+#endif
+	if (gpio_is_valid(priv->gpio_nreset))
+		/* Set codec to the reset state */
+		gpio_set_value(priv->gpio_nreset, 0);
+	printk("removing tas5711 successfull\n");
+	return 0;
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_tas5711 = {
+	.probe			= tas5711_probe,
+	.remove			= tas5711_remove,
+	.resume			= tas5711_soc_resume,
+	.controls		= tas5711_controls,
+	.num_controls		= ARRAY_SIZE(tas5711_controls),
+#if 0
+	.dapm_widgets		= tas5711_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(tas5711_dapm_widgets),
+	.dapm_routes		= tas5711_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(tas5711_dapm_routes),
+#endif
+};
+
+static const struct i2c_device_id tas5711_i2c_id[] = {
+	{ "tas5711", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tas5711_i2c_id);
+
+static const struct regmap_config tas5711_regmap = {
+	.reg_bits		= 8,
+	.val_bits		= 32,
+	.max_register		= TAS5711_MAX_REGISTER,
+	.reg_defaults		= tas5711_reg_defaults,
+	.num_reg_defaults	= ARRAY_SIZE(tas5711_reg_defaults),
+	.cache_type		= REGCACHE_RBTREE,
+	.volatile_reg		= tas5711_volatile_reg,
+	.writeable_reg		= tas5711_writeable_reg,
+	.readable_reg		= tas5711_accessible_reg,
+	.reg_read		= tas5711_reg_read,
+	.reg_write		= tas5711_reg_write,
+};
+
+static int tas5711_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	printk("+++++++++++++++++++in i2c probe+++++++++++++++++++++\n");
+	struct tas5711_private *priv;
+	struct device *dev = &i2c->dev;
+	int gpio_nreset = -EINVAL;
+	int i, ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		printk("devm_kzalloc() failed");
+		return -ENOMEM;
+	}
+
+	priv->regmap = devm_regmap_init(dev, NULL, i2c, &tas5711_regmap);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(&i2c->dev, "Failed to create regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, priv);
+
+	if (of_match_device(of_match_ptr(tas5711_dt_ids), dev)) {
+		struct device_node *of_node = dev->of_node;
+		gpio_nreset = of_get_named_gpio(of_node, "reset-gpio", 0);
+	}
+
+	if (gpio_is_valid(gpio_nreset))
+		if (devm_gpio_request(dev, gpio_nreset, "TAS5711 Reset")) {
+			gpio_nreset = -EINVAL;
+		}
+
+	if (gpio_is_valid(gpio_nreset)) {
+		/* Reset codec - minimum assertion time is 400ns */
+		gpio_direction_output(gpio_nreset, 0);
+		udelay(1);
+		gpio_set_value(gpio_nreset, 1);
+
+		/* Codec needs ~15ms to wake up */
+		msleep(15);
+	}
+
+	priv->gpio_nreset = gpio_nreset;
+
+#if 0
+	/* The TAS5086 always returns 0x03 in its TAS5086_DEV_ID register */
+	ret = regmap_read(priv->regmap, TAS5711_DEV_ID, &i);
+	if (ret < 0) {
+		printk ("regmap_read() failed\n");
+		return ret;
+	}
+
+	if (i != 0x3) {
+		dev_err(dev,
+			"Failed to identify TAS5711 codec (got %02x)\n", i);
+		return -ENODEV;
+	}
+#endif
+#if 0 // not needed
+	ret = regmap_read(priv->regmap, TAS5711_ERROR_STATUS, &i);
+	if (ret < 0) {
+		printk ("regmap_read() failed with code: %d\n", ret);
+		return ret;
+	}
+	else
+		printk ("Error status: %d\n", i);
+
+#endif
+
+	return snd_soc_register_codec(&i2c->dev, &soc_codec_dev_tas5711,
+		&tas5711_dai, 1);
+}
+
+static int tas5711_i2c_remove(struct i2c_client *i2c)
+{
+	printk("++++++++++++++ in tas5711_i2c_remove ++++++++++++++++++++\n");
+	snd_soc_unregister_codec(&i2c->dev);
+	printk("removing tas5711_i2c successfull\n");
+	return 0;
+}
+
+static struct i2c_driver tas5711_i2c_driver = {
+	.driver = {
+		.name	= "tas5711",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(tas5711_dt_ids),
+	},
+	.id_table	= tas5711_i2c_id,
+	.probe		= tas5711_i2c_probe,
+	.remove		= tas5711_i2c_remove,
+};
+
+module_i2c_driver(tas5711_i2c_driver);
+
+MODULE_AUTHOR("Felix Kramer <felixkramerroki@aol.com>");
+MODULE_DESCRIPTION("Texas Instruments TAS5711 ALSA SoC Codec Driver");
+MODULE_LICENSE("GPL");
+
